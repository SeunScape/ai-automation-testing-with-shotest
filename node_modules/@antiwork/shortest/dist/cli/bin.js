#!/usr/bin/env node
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@antiwork/shortest",
      version: "0.4.9",
      description: "AI-powered natural language end-to-end testing framework",
      type: "module",
      main: "./dist/index.js",
      module: "./dist/index.js",
      types: "./dist/index.d.ts",
      bin: {
        shortest: "./dist/cli/bin.js"
      },
      exports: {
        ".": {
          types: "./dist/index.d.ts",
          import: "./dist/index.js",
          require: "./dist/index.cjs"
        }
      },
      files: [
        "dist",
        "dist/cli",
        "src/shortest.config.ts.example"
      ],
      scripts: {
        build: "rimraf dist && pnpm build:types && pnpm build:js && pnpm build:cli",
        "build:pack": "pnpm build && pnpm pack",
        prepare: "pnpm build",
        prepublishOnly: "pnpm build",
        postinstall: `node -e "if (process.platform !== 'win32') { try { require('child_process').execSync('chmod +x dist/cli/bin.js') } catch (_) {} }"`,
        "build:types": "tsup src/index.ts --dts-only --format esm --outDir dist",
        "build:js": "esbuild src/index.ts --bundle --platform=node --format=esm --outfile=dist/index.js --external:esbuild --external:punycode --external:playwright --external:expect --external:dotenv --external:ai --external:@ai-sdk/* --external:@babel/* --external:tty",
        "build:cjs": "esbuild src/index.ts --bundle --platform=node --format=cjs --outfile=dist/index.cjs --external:esbuild --external:punycode --external:playwright --external:expect --external:dotenv --external:ai --external:@ai-sdk/* --external:@babel/* --external:tty",
        "build:cli": "node scripts/build-cli.js",
        dev: "pnpm build --watch",
        cli: "node dist/cli/bin.js",
        "test:unit": "npx vitest run",
        "test:unit:watch": "npx vitest --watch",
        "test:e2e": "node --import tsx --test tests/e2e/index.ts",
        "cache:clear": "pnpm build && shortest cache clear --force-purge"
      },
      dependencies: {
        "@babel/code-frame": "^7.26.2",
        "@babel/parser": "^7.26.9",
        "@babel/traverse": "^7.26.9",
        "@babel/types": "^7.26.9",
        "@inquirer/prompts": "^7.4.0",
        "@listr2/prompt-adapter-inquirer": "^2.0.18",
        "@netlify/framework-info": "^9.9.2",
        "@types/babel__traverse": "^7.20.6",
        "chromium-bidi": "^0.5.24",
        commander: "^13.1.0",
        glob: "^10.4.5",
        globby: "^14.1.0",
        listr2: "^8.2.5",
        otplib: "^12.0.1",
        picocolors: "^1.1.1",
        "simple-git": "^3.27.0"
      },
      devDependencies: {
        "@babel/generator": "^7.27.0",
        "@types/babel__generator": "^7.6.8",
        "@types/jest": "^29.5.14",
        "@types/node": "^20.17.17",
        "package-manager-detector": "0.2.9",
        rimraf: "^6.0.1",
        tsup: "^8.3.6",
        tsx: "^4.19.3",
        typescript: "~5.7.3",
        vitest: "^1.6.1",
        zod: "^3.24.2"
      },
      engines: {
        node: ">=18"
      },
      peerDependencies: {
        "@ai-sdk/anthropic": "^1.1.15",
        "@ai-sdk/provider": "^1.0.10",
        ai: "^4.1.53",
        dotenv: "^16.4.5",
        esbuild: "^0.20.1",
        expect: "^29.7.0",
        mailosaur: "^8.7.0",
        playwright: "^1.50.1"
      },
      author: "Antiwork",
      license: "MIT",
      repository: {
        directory: "packages/shortest",
        type: "git",
        url: "https://github.com/antiwork/shortest"
      },
      keywords: [
        "testing",
        "e2e",
        "ai",
        "automation",
        "browser",
        "playwright"
      ],
      bugs: {
        url: "https://github.com/antiwork/shortest/issues"
      },
      homepage: "https://github.com/antiwork/shortest#readme",
      publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
      }
    };
  }
});

// src/cli/bin.ts
import pc9 from "picocolors";

// src/cli/commands/analyze.ts
import { Command, Option } from "commander";

// src/log/log.ts
import pc3 from "picocolors";

// ../../node_modules/.pnpm/zod@3.24.2/node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t4 = typeof data;
  switch (t4) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path: path11, errorMaps, issueData } = params;
  const fullPath = [...path11, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path11, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path11;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input2) {
    return getParsedType(input2.data);
  }
  _getOrReturnCtx(input2, ctx) {
    return ctx || {
      common: input2.parent.common,
      data: input2.data,
      parsedType: getParsedType(input2.data),
      schemaErrorMap: this._def.errorMap,
      path: input2.path,
      parent: input2.parent
    };
  }
  _processInputParams(input2) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input2.parent.common,
        data: input2.data,
        parsedType: getParsedType(input2.data),
        schemaErrorMap: this._def.errorMap,
        path: input2.path,
        parent: input2.parent
      }
    };
  }
  _parseSync(input2) {
    const result = this._parse(input2);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input2) {
    const result = this._parse(input2);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = String(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input2.data.length < check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input2.data.length > check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input2.data.length > check.value;
        const tooSmall = input2.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input2.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input2.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input2.data = input2.data.trim();
      } else if (check.kind === "includes") {
        if (!input2.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input2.data = input2.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input2.data = input2.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input2.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input2.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input2.data, check.version)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input2.data, check.alg)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input2.data, check.version)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = Number(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input2.data < check.value : input2.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input2.data > check.value : input2.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input2.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input2) {
    if (this._def.coerce) {
      try {
        input2.data = BigInt(input2.data);
      } catch (_a) {
        return this._getInvalidInput(input2);
      }
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input2);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input2.data < check.value : input2.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input2.data > check.value : input2.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input2.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  _getInvalidInput(input2) {
    const ctx = this._getOrReturnCtx(input2);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = Boolean(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = new Date(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input2.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input2.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input2.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input2.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input2) {
    return OK(input2.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input2) {
    return OK(input2.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input2) {
    const ctx = this._getOrReturnCtx(input2);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input2) {
    const { ctx, status } = this._processInputParams(input2);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input2);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input2) {
    if (input2.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input2.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input2) {
    if (typeof input2.data !== "string") {
      const ctx = this._getOrReturnCtx(input2);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input2.data)) {
      const ctx = this._getOrReturnCtx(input2);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input2.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input2) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input2);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input2.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input2.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input2.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input2) {
    const result = this._def.innerType._parse(input2);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/log/config.ts
var LOG_LEVELS = [
  "trace",
  "debug",
  "info",
  "warn",
  "error",
  "silent"
];
var LOG_FORMATS = ["terminal", "pretty", "reporter"];
var LogConfigSchema = z.object({
  level: z.enum(LOG_LEVELS).default("silent"),
  format: z.enum(LOG_FORMATS).default("terminal")
});

// src/log/event.ts
var LogEvent = class _LogEvent {
  static FILTERED_METADATA_KEYS = ["anthropicKey", "apiKey"];
  static FILTERED_PLACEHOLDER = "[FILTERED]";
  static TRUNCATED_METADATA_KEYS = ["base64_image", "data"];
  static TRUNCATED_PLACEHOLDER = "[TRUNCATED]";
  /**
   * Recursively processes and filters values in metadata:
   * - Truncates nested objects beyond certain depth
   * - Masks sensitive keys (e.g., API keys) with [FILTERED] or partial value
   * - Truncates specified large fields with [TRUNCATED]
   * - Formats multiline strings with indentation
   * - Attempts JSON parsing of string values
   *
   * @param {string} key - Metadata key being processed
   * @param {any} value - Value to filter/process
   * @param {number} depth - Current recursion depth
   * @returns {any} Processed value
   *
   * @private
   */
  static filterValue(key, value, depth) {
    const MAX_METADATA_DEPTH = 5;
    if (depth > MAX_METADATA_DEPTH) {
      return _LogEvent.TRUNCATED_PLACEHOLDER;
    }
    if (_LogEvent.TRUNCATED_METADATA_KEYS.includes(key)) {
      return typeof value === "string" ? `${value.slice(0, 8)}...` : _LogEvent.TRUNCATED_PLACEHOLDER;
    }
    if (_LogEvent.FILTERED_METADATA_KEYS.includes(key)) {
      if (typeof value === "string") {
        if (value.length < 6) {
          return _LogEvent.FILTERED_PLACEHOLDER;
        } else if (value.length < 15) {
          return `${value.slice(0, 3)}...`;
        }
        return `${value.slice(0, 3)}...${value.slice(-3)}`;
      }
      return _LogEvent.FILTERED_PLACEHOLDER;
    }
    if (typeof value === "object" && value !== null) {
      return Object.fromEntries(
        Object.entries(value).map(([k, v]) => [
          k,
          _LogEvent.filterValue(k, v, depth + 1)
        ])
      );
    }
    if (typeof value === "string" && value.includes("\n")) {
      return "\n  " + value.split("\n").join("\n  ");
    }
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
  timestamp;
  level;
  message;
  metadata = {};
  _parsedMetadata = null;
  constructor(level, message, metadata) {
    this.timestamp = /* @__PURE__ */ new Date();
    this.level = level;
    this.message = message;
    this.metadata = metadata ?? {};
  }
  get parsedMetadata() {
    return this._parsedMetadata ??= this.parseMetadata();
  }
  parseMetadata() {
    if (!Object.keys(this.metadata).length)
      return void 0;
    return Object.fromEntries(
      Object.entries(this.metadata).map(([k, v]) => [
        k,
        _LogEvent.filterValue(k, v, 0)
      ])
    );
  }
};

// src/log/group.ts
var LogGroup = class {
  parent;
  name;
  event;
  log;
  constructor(log, name, parent) {
    this.log = log;
    this.name = name;
    this.parent = parent;
    this.event = new LogEvent("trace", name);
  }
  /**
   * Logs an info message in this group
   * @returns {this} For method chaining
   */
  info(message, metadata) {
    this.log.log("info", message, metadata);
    return this;
  }
  /**
   * Logs a warning message in this group
   * @returns {this} For method chaining
   */
  warn(message, metadata) {
    this.log.log("warn", message, metadata);
    return this;
  }
  /**
   * Logs an error message in this group
   * @returns {this} For method chaining
   */
  error(message, metadata) {
    this.log.log("error", message, metadata);
    return this;
  }
  /**
   * Logs a debug message in this group
   * @returns {this} For method chaining
   */
  debug(message, metadata) {
    this.log.log("debug", message, metadata);
    return this;
  }
  /**
   * Logs a trace message in this group
   * @returns {this} For method chaining
   */
  trace(message, metadata) {
    this.log.log("trace", message, metadata);
    return this;
  }
  /**
   * Gets array of group names from root to this group
   * @returns {string[]} Array of group names in hierarchical order
   */
  getGroupIdentifiers() {
    const identifiers = [];
    let current = this;
    while (current) {
      identifiers.unshift(current.name);
      current = current.parent;
    }
    return identifiers;
  }
};

// src/log/output.ts
import pc2 from "picocolors";

// src/utils/errors.ts
import pc from "picocolors";
var ShortestError = class extends Error {
  type;
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var ConfigErrorTypeSchema = z.enum([
  "duplicate-config",
  "file-not-found",
  "invalid-config",
  "multiple-config",
  "no-config"
]);
var ConfigError = class extends ShortestError {
  type;
  constructor(type, message) {
    super(message);
    this.type = ConfigErrorTypeSchema.parse(type);
  }
};
var AIErrorTypeSchema = z.enum([
  "invalid-response",
  "max-retries-reached",
  "token-limit-exceeded",
  "unsafe-content-detected",
  "unsupported-provider",
  "unknown"
]);
var AIError = class extends ShortestError {
  type;
  constructor(type, message) {
    super(message);
    this.type = AIErrorTypeSchema.parse(type);
  }
};
var CacheErrorTypeSchema = z.enum(["not-found", "invalid"]);
var CacheError = class extends ShortestError {
  type;
  constructor(type, message) {
    super(message);
    this.type = CacheErrorTypeSchema.parse(type);
  }
};
var ToolError = class extends ShortestError {
  constructor(message) {
    super(message);
    this.name = "ToolError";
  }
};
var TestErrorTypeSchema = z.enum([
  "callback-execution-failed",
  "assertion-failed"
]);
var TestError = class extends ShortestError {
  type;
  actual;
  expected;
  constructor(type, message, options) {
    super(message);
    this.type = TestErrorTypeSchema.parse(type);
    this.actual = options?.actual;
    this.expected = options?.expected;
  }
};
var getErrorDetails = (error) => {
  const metadata = {
    message: error instanceof Error ? error.message : String(error),
    name: error instanceof Error ? error.name : "Unknown",
    type: error instanceof ShortestError ? error.type : void 0,
    stack: error instanceof Error ? error.stack?.split("\n").slice(1, 4).join("\n") : void 0
  };
  return Object.fromEntries(
    Object.entries(metadata).filter(
      ([_, value]) => value !== null && value !== void 0
    )
  );
};
var formatZodError = (error, label) => {
  const errorsString = error.errors.map((err) => {
    const path11 = err.path.join(".");
    const prefix = path11 ? `${pc.cyan(path11)}: ` : "";
    const receivedInfo = "received" in err ? ` (received: ${JSON.stringify(err.received)})` : "";
    return `${prefix}${err.message}${receivedInfo}`;
  }).join("\n");
  return `${label}
${errorsString}`;
};
var asShortestError = (error) => error instanceof Error ? Object.assign(new ShortestError(error.message), error, {
  name: "ShortestError"
}) : new ShortestError(String(error));

// src/log/output.ts
var LogOutput = class _LogOutput {
  static MAX_LEVEL_LENGTH = Math.max(
    ...LOG_LEVELS.map((level) => level.length)
  );
  /**
   * Renders a log event
   *
   * @param {LogEvent} event - Event to render
   * @param {LogFormat} format - Output format
   * @param {LogGroup} [group] - Optional group
   * @throws {Error} If format is unsupported
   */
  static render(event, format, outputStream, group) {
    let output = "";
    switch (format) {
      case "terminal":
        output = _LogOutput.renderForTerminal(event, group);
        break;
      case "reporter":
        output = _LogOutput.renderForReporter(event, group);
        break;
      default:
        throw new ConfigError(
          "invalid-config",
          `Unsupported log format: ${format}`
        );
    }
    let stream = outputStream;
    if (outputStream === process.stdout) {
      if (event.level === "error" || event.level === "warn") {
        stream = process.stderr;
      }
    }
    stream.write(`${output}
`);
  }
  static renderForReporter(event, group) {
    const INDENTATION_CHARACTER = "  ";
    const { message } = event;
    const groupIdentifiers = group ? group.getGroupIdentifiers() : [];
    let outputParts = [];
    if (groupIdentifiers.length > 0) {
      outputParts.push(INDENTATION_CHARACTER.repeat(groupIdentifiers.length));
    }
    outputParts.push(message);
    return outputParts.join("");
  }
  static renderForTerminal(event, group) {
    const { level, timestamp, parsedMetadata } = event;
    let { message } = event;
    const groupIdentifiers = group ? group.getGroupIdentifiers() : [];
    let colorFn = pc2.white;
    switch (level) {
      case "error":
        colorFn = pc2.red;
        break;
      case "warn":
        colorFn = pc2.yellow;
        break;
      case "info":
        colorFn = pc2.cyan;
        break;
      case "debug":
        colorFn = pc2.green;
        break;
      case "trace":
        colorFn = pc2.gray;
        break;
    }
    if (event.level === "error") {
      message = pc2.red(message);
    }
    let outputParts = [];
    outputParts.push(colorFn(`${level}`.padEnd(_LogOutput.MAX_LEVEL_LENGTH)));
    outputParts.push(
      timestamp.toLocaleTimeString("en-US", {
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      })
    );
    outputParts.push(...groupIdentifiers.map((name) => pc2.dim(name)));
    outputParts.push(message);
    if (parsedMetadata) {
      const formattedMetadata = typeof parsedMetadata === "string" ? parsedMetadata : Object.entries(parsedMetadata).map(([k, v]) => {
        const value = typeof v === "string" ? v.replace(/\\"/g, '"').replace(/\\n/g, "\n") : v === null || v === void 0 ? "null" : JSON.stringify(v, null, 2).replace(/\\n/g, "\n");
        return `${pc2.dim(k)}=${value}${typeof value === "string" && value.includes("\n") ? "\n" : ""}`;
      }).join(" ");
      outputParts.push(formattedMetadata);
    }
    const output = outputParts.join(" | ");
    if (event.level === "warn") {
      return pc2.yellowBright(output);
    }
    return output;
  }
};

// src/log/log.ts
var Log = class {
  config;
  // private events: LogEvent[] = [];
  currentGroup;
  outputStream;
  constructor(config = {}) {
    try {
      this.config = LogConfigSchema.parse(config);
      this.outputStream = process.stdout;
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ConfigError(
          "invalid-config",
          formatZodError(error, "Invalid shortest.config")
        );
      }
      throw error;
    }
  }
  /**
   * Core logging method that handles metadata extraction and event creation
   */
  log(level, ...args) {
    const metadata = args[args.length - 1]?.constructor === Object ? args.pop() : void 0;
    const message = args.map((arg) => String(arg)).join(" ");
    const event = new LogEvent(level, message, metadata);
    this.outputEvent(event);
  }
  /**
   * Creates a new log group for organizing related logs
   */
  setGroup(name) {
    this.currentGroup = new LogGroup(this, name, this.currentGroup);
  }
  /**
   * Resets to parent group or removes grouping if at root
   */
  resetGroup() {
    const callerMatch = new Error().stack?.split("\n")[2]?.match(/at\s+(\S+)\s+/);
    if (this.currentGroup) {
      this.currentGroup = this.currentGroup?.parent;
    } else {
      this.log("trace", "No group to reset", {
        calledBy: callerMatch?.[1] || "unknown"
      });
    }
  }
  /**
   * Removes all group nesting
   */
  resetAllGroups() {
    this.currentGroup = void 0;
  }
  /**
   * Convenience methods for different log levels
   */
  trace(...args) {
    this.log("trace", ...args);
  }
  debug(...args) {
    this.log("debug", ...args);
  }
  info(...args) {
    this.log("info", ...args);
  }
  warn(...args) {
    this.log("warn", ...args);
  }
  error(...args) {
    this.log("error", ...args);
  }
  setOutputStream(stream) {
    this.outputStream = stream;
    return this;
  }
  resetOutputStream() {
    this.outputStream = process.stdout;
    return this;
  }
  /**
   * Checks if a log level should be output based on configured minimum level
   */
  shouldLog(level) {
    return LOG_LEVELS.indexOf(level) >= LOG_LEVELS.indexOf(this.config.level);
  }
  /**
   * Processes and outputs a log event if it meets the minimum level requirement
   */
  outputEvent(event) {
    if (this.shouldLog(event.level)) {
      LogOutput.render(
        event,
        this.config.format,
        this.outputStream,
        this.currentGroup
      );
    } else if (event.level === "warn") {
      console.warn(
        pc3.bgYellowBright(pc3.black(" WARN ")),
        pc3.yellow(event.message)
      );
    }
  }
};

// src/log/index.ts
var instance = null;
var getLogger = (config) => {
  if (instance) {
    return instance;
  }
  instance = new Log(config);
  return instance;
};

// src/cli/utils/command-builder.ts
var executeCommand = async (name, options, fn) => {
  const log = getLogger({
    level: options.logLevel
  });
  try {
    log.trace(`Executing ${name} command`, { options });
    await fn(options);
  } catch (error) {
    log.error(`Command ${name} failed`, getErrorDetails(error));
    throw error;
  }
};

// src/core/app-analyzer/index.ts
import fs6 from "fs/promises";
import path6 from "path";

// src/cache/index.ts
import { existsSync } from "fs";
import * as fs3 from "fs/promises";
import path2 from "path";

// src/core/runner/test-run-repository.ts
import * as fs from "fs/promises";
import path from "path";

// src/core/runner/test-run.ts
var TestRun = class _TestRun {
  /**
   * Creates a new TestRun instance from a test case
   * @param {TestCase} testCase - The test case to be executed
   * @returns {TestRun} A new TestRun instance with pending status
   */
  static create(testCase) {
    const log = getLogger();
    const startedAt = /* @__PURE__ */ new Date();
    const timestamp = startedAt.getTime();
    const formattedStartedAt = startedAt.toISOString().replace(/[:.]/g, "-");
    const runId = `${formattedStartedAt}_${testCase.identifier}`;
    log.trace("Creating TestRun", {
      runId
    });
    return new _TestRun(testCase, {
      runId,
      timestamp,
      executedFromCache: false
    });
  }
  /**
   * Creates a TestRun instance from a cache entry
   * @param {TestCase} testCase - The test case associated with this run
   * @param {CacheEntry} cacheEntry - The cache entry data
   * @returns {TestRun} A new TestRun instance
   *
   * @private
   */
  static fromCache(testCase, cacheEntry) {
    const log = getLogger();
    log.trace("Creating TestRun from cache", {
      runId: cacheEntry.metadata.runId,
      stepCount: cacheEntry.data.steps?.length
    });
    const testRun = new _TestRun(testCase, {
      runId: cacheEntry.metadata.runId,
      timestamp: cacheEntry.metadata.timestamp,
      executedFromCache: cacheEntry.metadata.executedFromCache
    });
    testRun.version = typeof cacheEntry.metadata.version === "string" ? parseInt(cacheEntry.metadata.version, 10) || 0 : cacheEntry.metadata.version || 0;
    testRun.state = {
      status: cacheEntry.metadata.status,
      reason: cacheEntry.metadata.reason
    };
    testRun.tokenUsage = cacheEntry.metadata.tokenUsage;
    if (cacheEntry.data.steps) {
      testRun.steps = [...cacheEntry.data.steps];
    }
    return testRun;
  }
  testCase;
  log;
  runId;
  timestamp;
  steps = [];
  tokenUsage = {
    completionTokens: 0,
    promptTokens: 0,
    totalTokens: 0
  };
  version = TestRunRepository.VERSION;
  _executedFromCache = false;
  state = { status: "pending" };
  constructor(testCase, {
    runId,
    timestamp,
    executedFromCache
  }) {
    this.testCase = testCase;
    this.log = getLogger();
    this.runId = runId;
    this.timestamp = timestamp;
    this._executedFromCache = executedFromCache;
  }
  /**
   * Gets whether this test run was executed from cache
   * @returns {boolean} True if executed from cache, false otherwise
   */
  get executedFromCache() {
    return this._executedFromCache;
  }
  /**
   * Gets the reason for the current test status
   * @returns {string|undefined} The reason string or undefined if not set
   */
  get reason() {
    return this.state.reason;
  }
  /**
   * Gets the current test status
   * @returns {TestStatus} The current status of the test
   */
  get status() {
    return this.state.status;
  }
  /**
   * Marks the test as running
   * @throws {ShortestError} If test is not in pending state
   */
  markRunning() {
    if (this.status !== "pending")
      throw new ShortestError("Can only start from pending state");
    this.state = { status: "running" };
  }
  /**
   * Marks the test as passed
   * @param {Object} options - Pass options
   * @param {string} options.reason - Reason for passing
   * @param {TokenUsage} [options.tokenUsage] - Optional token usage stats
   * @throws {ShortestError} If test is not in running state
   *
   * @private
   */
  markPassed({
    reason,
    tokenUsage
  }) {
    if (this.status !== "running")
      throw new ShortestError("Can only pass from running state");
    this.state = { status: "passed", reason };
    if (tokenUsage)
      this.tokenUsage = tokenUsage;
  }
  /**
   * Marks the test run as passed when it used a cached test run to be executed
   * @param {Object} options - Options
   * @param {string} options.reason - Reason for passing
   */
  markPassedFromCache({ reason }) {
    this.markPassed({ reason });
    this._executedFromCache = true;
  }
  /**
   * Marks the test as failed
   * @param {Object} options - Fail options
   * @param {string} options.reason - Reason for failure
   * @param {TokenUsage} [options.tokenUsage] - Optional token usage stats
   *
   * @private
   */
  markFailed({
    reason,
    tokenUsage
  }) {
    this.state = { status: "failed", reason };
    if (tokenUsage)
      this.tokenUsage = tokenUsage;
  }
  /**
   * Adds a step to the test run
   * @param {CacheStep} step - The step to add to the test run
   */
  addStep(step) {
    this.steps.push(step);
  }
  /**
   * Gets all steps in this test run
   * @returns {CacheStep[]} A copy of the steps array
   */
  getSteps() {
    return [...this.steps];
  }
};

// src/core/runner/test-run-repository.ts
var handlersRegistered = false;
var registerSharedProcessHandlers = (log) => {
  if (handlersRegistered)
    return TestRunRepository.activeRepositories;
  const activeRepositories = /* @__PURE__ */ new Set();
  const cleanUpAndExit = async () => {
    await Promise.all(
      [...activeRepositories].map((repo) => repo.releaseLock())
    );
  };
  process.on("exit", cleanUpAndExit);
  process.on("SIGINT", cleanUpAndExit);
  process.on("SIGTERM", cleanUpAndExit);
  process.on("uncaughtException", async (error) => {
    log.error("Uncaught exception", getErrorDetails(error));
    await cleanUpAndExit();
  });
  handlersRegistered = true;
  return activeRepositories;
};
var TestRunRepository = class _TestRunRepository {
  static VERSION = 3;
  static activeRepositories;
  static repositoriesByIdentifier = /* @__PURE__ */ new Map();
  /**
   * Gets or creates a repository for the specified test case
   *
   * @param {TestCase} testCase - Test case to get repository for
   * @returns {TestRunRepository} Repository instance
   */
  static getRepositoryForTestCase(testCase) {
    const log = getLogger();
    const key = testCase.identifier;
    if (!_TestRunRepository.repositoriesByIdentifier.has(key)) {
      log.trace("Creating new repository", { identifier: key });
      const repository = new _TestRunRepository(testCase);
      _TestRunRepository.repositoriesByIdentifier.set(key, repository);
    }
    return _TestRunRepository.repositoriesByIdentifier.get(key);
  }
  testCase;
  lockFileName;
  globalCacheDir;
  log;
  MAX_LOCK_ATTEMPTS = 10;
  BASE_LOCK_DELAY_MS = 10;
  lockAcquired = false;
  testRuns = null;
  /**
   * Creates a new test run repository instance
   *
   * @param {TestCase} testCase - Test case to manage runs for
   * @param {string} cacheDir - Directory to store cache files in
   */
  constructor(testCase, cacheDir = CACHE_DIR_PATH) {
    this.log = getLogger();
    this.log.trace("Initializing TestRunRepository", {
      identifier: testCase.identifier
    });
    this.testCase = testCase;
    this.globalCacheDir = cacheDir;
    this.lockFileName = `${this.testCase.identifier}.lock`;
    _TestRunRepository.activeRepositories = registerSharedProcessHandlers(this.log) || _TestRunRepository.activeRepositories;
    _TestRunRepository.activeRepositories.add(this);
  }
  get lockFilePath() {
    return path.join(this.globalCacheDir, this.lockFileName);
  }
  /**
   * Gets all test runs for the associated test case
   *
   * @returns {Promise<TestRun[]>} Array of test runs
   */
  async getRuns() {
    if (this.testRuns !== null) {
      return this.testRuns;
    }
    this.log.trace("Getting test runs", {
      identifier: this.testCase.identifier
    });
    const files = (await fs.readdir(this.globalCacheDir)).filter(
      (f) => f.endsWith(`${this.testCase.identifier}.json`)
    );
    const loadedTestRuns = [];
    for (const file of files) {
      try {
        const filePath = path.join(this.globalCacheDir, file);
        const content = await fs.readFile(filePath, "utf-8");
        const cacheEntry = JSON.parse(content);
        loadedTestRuns.push(TestRun.fromCache(this.testCase, cacheEntry));
      } catch (error) {
        this.log.error("Failed to load test run from cache", {
          file,
          ...getErrorDetails(error)
        });
      }
    }
    this.testRuns = loadedTestRuns;
    return this.testRuns;
  }
  /**
   * Gets the most recent passed test run
   *
   * @returns {Promise<TestRun | null>} Latest passed test run or null if none exists
   */
  async getLatestPassedRun() {
    this.log.trace("Getting latest passed run", {
      identifier: this.testCase.identifier
    });
    const testRuns = await this.getRuns();
    const validTestRuns = testRuns.filter(
      (testRun) => testRun.status === "passed" && testRun.version === _TestRunRepository.VERSION && !testRun.executedFromCache
    );
    this.log.trace("Found test runs", {
      identifier: this.testCase.identifier,
      totalRunsCount: testRuns.length,
      validRunsCount: validTestRuns.length,
      validRunIds: validTestRuns.map((run) => run.runId)
    });
    return validTestRuns.length > 0 ? validTestRuns[validTestRuns.length - 1] : null;
  }
  /**
   * Saves a test run to the cache
   *
   * @param {TestRun} testRun - Test run to save
   * @returns {Promise<void>}
   */
  async saveRun(testRun) {
    if (!await this.acquireLock()) {
      this.log.error("Failed to acquire lock for saving run");
      return;
    }
    this.log.trace("Saving test run", {
      runId: testRun.runId,
      status: testRun.status,
      stepCount: testRun.steps.length,
      executedFromCache: testRun.executedFromCache
    });
    try {
      const cacheEntry = {
        metadata: {
          timestamp: Date.now(),
          version: _TestRunRepository.VERSION,
          status: testRun.status,
          reason: testRun.reason,
          tokenUsage: testRun.tokenUsage,
          runId: testRun.runId,
          executedFromCache: testRun.executedFromCache
        },
        test: {
          name: this.testCase.name,
          filePath: this.testCase.filePath
        },
        data: {
          steps: testRun.getSteps()
        }
      };
      await fs.writeFile(
        this.getTestRunFilePath(testRun),
        JSON.stringify(cacheEntry, null, 2),
        "utf-8"
      );
    } finally {
      this.resetTestRuns();
      await this.releaseLock();
    }
  }
  /**
   * Deletes a test run and its associated files
   *
   * @param {TestRun} testRun - Test run to delete
   * @returns {Promise<void>}
   */
  async deleteRun(testRun) {
    this.log.trace("Deleting test run", {
      runId: testRun.runId
    });
    try {
      await fs.unlink(this.getTestRunFilePath(testRun));
      this.resetTestRuns();
    } catch (error) {
      this.log.trace("Cache file not found", {
        cacheFileName: this.getTestRunFilePath(testRun),
        ...getErrorDetails(error)
      });
    }
    try {
      await fs.rm(this.getTestRunDirPath(testRun), {
        recursive: true,
        force: true
      });
    } catch (error) {
      this.log.error("Failed to delete cache directory", {
        cacheDirName: this.getTestRunDirPath(testRun),
        ...getErrorDetails(error)
      });
    }
  }
  /**
   * Applies retention policy to limit disk usage
   *
   * Keeps only the latest passed run, or if no passed runs exist,
   * keeps only the most recent run.
   *
   * @returns {Promise<void>}
   */
  async applyRetentionPolicy() {
    this.log.setGroup("\u{1F5D1}\uFE0F");
    this.log.trace("Applying test run repository retention policy", {
      identifier: this.testCase.identifier
    });
    const allRuns = await this.getRuns();
    const latestPassedRun = await this.getLatestPassedRun();
    let deletedCount = 0;
    for (const run of allRuns) {
      if (run.version < _TestRunRepository.VERSION) {
        this.log.trace("Deleting run with outdated version", {
          runId: run.runId,
          version: run.version,
          currentVersion: _TestRunRepository.VERSION
        });
        await this.deleteRun(run);
        deletedCount++;
      }
    }
    if (latestPassedRun) {
      for (const run of allRuns) {
        if (run.version === _TestRunRepository.VERSION && run.runId !== latestPassedRun.runId) {
          this.log.trace("Deleting run (keeping only latest passed)", {
            runId: run.runId,
            status: run.status
          });
          await this.deleteRun(run);
          deletedCount++;
        }
      }
      this.log.trace("Retention policy applied successfully", {
        keptRunId: latestPassedRun.runId,
        deletedCount
      });
    } else {
      const MAX_RUNS_PER_TEST = 1;
      const currentVersionRuns = allRuns.filter(
        (run) => run.version === _TestRunRepository.VERSION && !run.executedFromCache
      );
      if (currentVersionRuns.length > 0) {
        const sortedRuns = [...currentVersionRuns].sort(
          (a, b) => b.timestamp - a.timestamp
        );
        const runsToKeep = sortedRuns.slice(0, MAX_RUNS_PER_TEST);
        const runIdsToKeep = new Set(runsToKeep.map((run) => run.runId));
        for (const run of currentVersionRuns) {
          if (!runIdsToKeep.has(run.runId)) {
            this.log.trace("Deleting run (exceeds max runs per test)", {
              runId: run.runId,
              status: run.status,
              maxRuns: MAX_RUNS_PER_TEST
            });
            await this.deleteRun(run);
            deletedCount++;
          }
        }
        if (runsToKeep.length === 1) {
          this.log.trace("Keeping latest run", {
            keptRunId: runsToKeep[0].runId,
            status: runsToKeep[0].status,
            deletedCount
          });
        } else {
          this.log.trace(`Keeping ${runsToKeep.length} most recent runs`, {
            keptRunIds: runsToKeep.map((run) => run.runId),
            deletedCount
          });
        }
      }
    }
    this.resetTestRuns();
    this.log.resetGroup();
  }
  /**
   * Releases previously acquired lock
   *
   * @returns {Promise<void>}
   */
  async releaseLock() {
    if (this.lockAcquired) {
      try {
        await fs.unlink(this.lockFilePath);
        this.lockAcquired = false;
        _TestRunRepository.activeRepositories.delete(this);
      } catch (error) {
        if (error.code !== "ENOENT") {
          this.log.error("Failed to release lock", {
            lockFilePath: this.lockFilePath,
            ...getErrorDetails(error)
          });
        }
      }
    }
  }
  /**
   * Ensures the test run directory exists and returns its path
   *
   * @param {TestRun} testRun - Test run to ensure directory for
   * @returns {Promise<string>} Path to the test run directory
   */
  async ensureTestRunDirPath(testRun) {
    const runDirPath = path.join(this.globalCacheDir, testRun.runId);
    await fs.mkdir(runDirPath, { recursive: true });
    this.resetTestRuns();
    return runDirPath;
  }
  /**
   * Acquires a lock for cache file access
   *
   * Uses exponential backoff to retry lock acquisition
   *
   * @returns {Promise<boolean>} True if lock was acquired, false otherwise
   * @private
   */
  async acquireLock() {
    const lockData = { pid: process.pid, timestamp: Date.now() };
    for (let attempt = 0; attempt < this.MAX_LOCK_ATTEMPTS; attempt++) {
      try {
        await fs.writeFile(this.lockFilePath, JSON.stringify(lockData), {
          flag: "wx"
        });
        this.lockAcquired = true;
        return true;
      } catch (error) {
        if (error.code === "EEXIST") {
          const lockContent = await fs.readFile(this.lockFilePath, "utf-8").catch(() => null);
          if (lockContent) {
            try {
              const { pid, timestamp } = JSON.parse(lockContent);
              const age = Date.now() - timestamp;
              if (age > 1e4 && !this.isProcessAlive(pid)) {
                await fs.unlink(this.lockFilePath).catch(() => {
                });
                continue;
              }
            } catch (parseError) {
              this.log.error("Failed to parse lock file", {
                lockFilePath: this.lockFilePath,
                ...getErrorDetails(parseError)
              });
            }
          }
          const delay = this.BASE_LOCK_DELAY_MS * Math.pow(2, attempt);
          await new Promise((resolve2) => setTimeout(resolve2, delay));
        } else {
          this.log.error("Unexpected lock acquisition error", {
            lockFileName: this.lockFileName,
            ...getErrorDetails(error)
          });
          return false;
        }
      }
    }
    this.log.error("Failed to acquire lock after max attempts", {
      lockFileName: this.lockFileName
    });
    return false;
  }
  /**
   * Checks if a process is still running
   *
   * @param {number} pid - Process ID to check
   * @returns {boolean} True if process is alive, false otherwise
   * @private
   */
  isProcessAlive(pid) {
    try {
      process.kill(pid, 0);
      return true;
    } catch (error) {
      this.log.error(
        "Failed to check if process is alive",
        getErrorDetails(error)
      );
      return false;
    }
  }
  /**
   * Gets the file path for a test run's cache file
   *
   * @param {TestRun} testRun - Test run to get file path for
   * @returns {string} Path to the cache file
   * @private
   */
  getTestRunFilePath(testRun) {
    return path.join(this.globalCacheDir, `${testRun.runId}.json`);
  }
  /**
   * Gets the directory path for a test run's artifacts
   *
   * @param {TestRun} testRun - Test run to get directory path for
   * @returns {string} Path to the test run directory
   * @private
   */
  getTestRunDirPath(testRun) {
    return path.join(this.globalCacheDir, testRun.runId);
  }
  /**
   * Resets the cached test runs to force reloading from disk
   *
   * @private
   */
  resetTestRuns() {
    this.testRuns = null;
  }
};

// src/utils/directory-exists.ts
import { constants } from "fs";
import * as fs2 from "fs/promises";
var directoryExists = async (path11) => {
  try {
    await fs2.access(path11, constants.F_OK);
    return true;
  } catch {
    return false;
  }
};

// src/cache/index.ts
var DOT_SHORTEST_DIR_NAME = ".shortest";
var DOT_SHORTEST_DIR_PATH = path2.join(
  process.cwd(),
  DOT_SHORTEST_DIR_NAME
);
var CACHE_DIR_PATH = path2.join(DOT_SHORTEST_DIR_PATH, "cache");
var CACHE_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
var cleanUpCache = async ({
  forcePurge = false,
  dirPath = CACHE_DIR_PATH
} = {}) => {
  const log = getLogger();
  log.setGroup("\u{1F9F9}");
  log.trace("Cleaning up cache", { forcePurge });
  if (!existsSync(dirPath)) {
    log.trace("Cache directory does not exist", { dirPath });
    return;
  }
  if (forcePurge) {
    await fs3.rm(dirPath, { recursive: true, force: true });
    log.debug("Cache directory purged", { dirPath });
    return;
  }
  const cacheFiles = await fs3.readdir(dirPath);
  log.trace("Found cache files", {
    count: cacheFiles.length
  });
  for (const cacheFile of cacheFiles) {
    if (!cacheFile.endsWith(".json"))
      continue;
    const cacheFilePath = path2.join(dirPath, cacheFile);
    const cacheDirPath = path2.join(dirPath, path2.parse(cacheFile).name);
    try {
      const content = await fs3.readFile(cacheFilePath, "utf-8");
      const entry = JSON.parse(content);
      const isOutdatedVersion = entry.metadata.version < TestRunRepository.VERSION;
      const testFileExists = existsSync(
        path2.join(process.cwd(), entry.test.filePath)
      );
      if (isOutdatedVersion || !testFileExists) {
        await fs3.unlink(cacheFilePath);
        await fs3.rm(cacheDirPath, { recursive: true, force: true });
        log.trace("Cache removed", {
          file: cacheFile,
          reason: isOutdatedVersion ? "outdated version" : "test file no longer exists"
        });
      }
    } catch (error) {
      log.error("Failed to process cache file", {
        file: cacheFilePath,
        ...getErrorDetails(error)
      });
      await fs3.unlink(cacheFilePath);
      await fs3.rm(cacheDirPath, { recursive: true, force: true });
      log.error("Invalid cache file removed", { file: cacheFilePath });
    }
  }
  log.trace("Cache clean-up complete");
  log.resetGroup();
};
var purgeLegacyCache = async ({
  dirPath = DOT_SHORTEST_DIR_PATH
} = {}) => {
  const log = getLogger();
  const legacyCachePath = path2.join(dirPath, "cache.json");
  if (!existsSync(legacyCachePath)) {
    return;
  }
  log.warn(`Purging legacy cache file (v0.4.3 and below): ${legacyCachePath}`);
  try {
    await fs3.unlink(legacyCachePath);
    log.debug(`Legacy cache file ${legacyCachePath} purged`);
  } catch (error) {
    if (error.code !== "ENOENT") {
      log.error("Failed to purge legacy cache file", {
        file: legacyCachePath,
        ...getErrorDetails(error)
      });
    }
  }
};
var purgeLegacyScreenshots = async () => {
  const log = getLogger();
  const legacyScreenshotsPath = path2.join(DOT_SHORTEST_DIR_PATH, "screenshots");
  if (!await directoryExists(legacyScreenshotsPath)) {
    return;
  }
  log.warn(`Purging legacy screenshots directory: ${legacyScreenshotsPath}`);
  try {
    await fs3.rm(legacyScreenshotsPath, { recursive: true, force: true });
    log.debug(`Legacy screenshots directory ${legacyScreenshotsPath} purged`);
  } catch (error) {
    log.error("Failed to purge legacy screenshots directory", {
      path: legacyScreenshotsPath,
      ...getErrorDetails(error)
    });
  }
};

// src/core/app-analyzer/next-js-analyzer.ts
import fs4 from "fs/promises";
import { createRequire } from "module";
import path4 from "path";
import * as parser from "@babel/parser";
import * as t from "@babel/types";

// src/core/app-analyzer/utils/get-tree-structure.ts
import path3 from "path";
import { globby } from "globby";
var FileNodeSchema = z.object({
  path: z.string(),
  name: z.string(),
  type: z.literal("file"),
  extension: z.string()
});
var DirectoryNodeSchema = z.object({
  path: z.string(),
  name: z.string(),
  type: z.literal("directory"),
  children: z.lazy(() => z.array(TreeNodeSchema))
});
var TreeNodeSchema = z.union([DirectoryNodeSchema, FileNodeSchema]);
var getPaths = async (sourceDir) => {
  const paths = await globby(["**/*"], {
    cwd: sourceDir,
    gitignore: true,
    ignore: [
      "**/*.test.ts",
      "**/*.test.tsx",
      "**/*.test.js",
      "**/*.test.jsx",
      "**/*.spec.ts",
      "**/*.spec.tsx",
      "**/*.spec.js",
      "**/*.spec.jsx",
      "packages/**",
      "test/**",
      "tests/**"
    ]
  });
  paths.sort();
  return paths;
};
var getTreeStructure = async (sourceDir) => {
  const log = getLogger();
  log.trace("Building application structure tree...");
  const paths = await getPaths(sourceDir);
  const rootNode = {
    path: "",
    name: path3.basename(sourceDir),
    type: "directory",
    children: []
  };
  const dirMap = /* @__PURE__ */ new Map();
  dirMap.set("", rootNode);
  const ensureDirectoryPath = (dirPath) => {
    if (dirMap.has(dirPath)) {
      return dirMap.get(dirPath);
    }
    const parentPath = path3.dirname(dirPath);
    const parentNode = parentPath === "." ? rootNode : ensureDirectoryPath(parentPath);
    const dirName = path3.basename(dirPath);
    const dirNode = {
      path: dirPath,
      name: dirName,
      type: "directory",
      children: []
    };
    parentNode.children.push(dirNode);
    dirMap.set(dirPath, dirNode);
    return dirNode;
  };
  for (const filePath of paths) {
    if (!filePath)
      continue;
    const isDirectory = !path3.extname(filePath);
    if (isDirectory) {
      ensureDirectoryPath(filePath);
    } else {
      const dirPath = path3.dirname(filePath);
      const parentNode = dirPath === "." ? rootNode : ensureDirectoryPath(dirPath);
      const fileName = path3.basename(filePath);
      const fileNode = {
        path: filePath,
        name: fileName,
        type: "file",
        extension: path3.extname(filePath)
      };
      parentNode.children.push(fileNode);
    }
  }
  return rootNode;
};

// src/utils/assert.ts
var assert = (condition, msg = "Assertion failed") => {
  if (!condition) {
    throw new ShortestError(msg);
  }
};
var assertDefined = (value, msg) => {
  assert(value != null, msg);
  return value;
};

// src/utils/get-git-info.ts
import { simpleGit } from "simple-git";
var getGitInfo = async () => {
  const log = getLogger();
  try {
    const git = simpleGit();
    const branchInfo = await git.branch();
    return {
      branch: branchInfo.current,
      commit: await git.revparse(["HEAD"])
    };
  } catch (error) {
    log.error("Failed to get git info", getErrorDetails(error));
    return {
      branch: null,
      commit: null
    };
  }
};

// src/core/app-analyzer/next-js-analyzer.ts
var require2 = createRequire(import.meta.url);
var traverse = require2("@babel/traverse").default;
var NextJsAnalyzer = class {
  layouts = {};
  routes = [];
  apiRoutes = [];
  results = [];
  pages = [];
  paths = [];
  apis = [];
  isAppRouter = false;
  isPagesRouter = false;
  fileInfos = [];
  log = getLogger();
  NEXT_ANALYSIS_VERSION = 2;
  frameworkInfo;
  cacheFrameworkDir;
  constructor(frameworkInfo) {
    this.frameworkInfo = frameworkInfo;
    this.cacheFrameworkDir = path4.join(
      DOT_SHORTEST_DIR_PATH,
      this.frameworkInfo.id
    );
  }
  async execute() {
    this.log.trace("Executing NextJs analyzer");
    this.layouts = {};
    this.routes = [];
    this.apiRoutes = [];
    this.pages = [];
    this.paths = [];
    this.apis = [];
    this.isAppRouter = false;
    this.isPagesRouter = false;
    await this.setPaths();
    await this.setTreeStructure();
    this.log.debug(`Processing ${this.fileInfos.length} files`);
    this.detectRouterType();
    await this.parseFiles();
    await this.processLayoutFiles();
    await this.processRouteFiles();
    this.log.debug(
      `Analysis generated: ${this.pages.length} pages, ${this.apis.length} API routes, ${Object.keys(this.layouts).length} layouts`
    );
    const analysis = this.generateAnalysis();
    await this.saveAnalysisToFile(analysis);
    return analysis;
  }
  async setPaths() {
    this.log.trace("Retrieving folder paths for NextJs analyzer");
    this.paths = await getPaths(this.frameworkInfo.dirPath);
    await fs4.mkdir(this.cacheFrameworkDir, { recursive: true });
    const pathsOutput = {
      metadata: {
        timestamp: Date.now(),
        version: this.NEXT_ANALYSIS_VERSION,
        git: await getGitInfo()
      },
      data: {
        framework: this.frameworkInfo,
        paths: this.paths
      }
    };
    await fs4.writeFile(
      path4.join(this.cacheFrameworkDir, "paths.json"),
      JSON.stringify(pathsOutput, null, 2)
    );
    this.log.trace("Paths saved", {
      path: path4.join(this.cacheFrameworkDir, "paths.json")
    });
  }
  async setTreeStructure() {
    this.log.setGroup("\u{1F333}");
    this.log.trace("Building tree structure for NextJs analyzer");
    try {
      const treeNode = await getTreeStructure(this.frameworkInfo.dirPath);
      this.setFileInfos(treeNode);
      await fs4.mkdir(this.cacheFrameworkDir, { recursive: true });
      const treeJsonPath = path4.join(this.cacheFrameworkDir, "tree.json");
      const treeOutput = {
        metadata: {
          timestamp: Date.now(),
          version: this.NEXT_ANALYSIS_VERSION,
          git: await getGitInfo()
        },
        data: {
          framework: this.frameworkInfo,
          node: treeNode
        }
      };
      await fs4.writeFile(treeJsonPath, JSON.stringify(treeOutput, null, 2));
      this.log.trace("Tree structure saved", { path: treeJsonPath });
    } catch (error) {
      this.log.error("Failed to build tree structure", getErrorDetails(error));
      throw error;
    } finally {
      this.log.resetGroup();
    }
  }
  setFileInfos(node) {
    if (node.type === "directory" && node.children) {
      for (const child of node.children) {
        this.setFileInfos(child);
      }
    } else if (node.type === "file") {
      this.fileInfos.push({
        relativeFilePath: node.path,
        relativeDirPath: path4.dirname(node.path),
        absoluteFilePath: path4.resolve(this.frameworkInfo.dirPath, node.path),
        name: node.name,
        extension: node.extension,
        content: null,
        ast: null
      });
    }
  }
  generateAnalysis() {
    const routeInfoList = this.pages.map((page) => ({
      routePath: page.routePath,
      relativeFilePath: page.relativeFilePath,
      layoutChain: this.getLayoutChainForPage(page.relativeFilePath),
      components: page.components,
      hasParams: page.hasParams,
      hasForm: page.hasFormSubmission,
      hooks: this.getHooksForFile(page.relativeFilePath),
      eventHandlers: this.getEventHandlersForFile(page.relativeFilePath),
      featureFlags: []
    }));
    const apiRouteInfoList = this.apis.map((api) => ({
      routePath: api.routePath,
      relativeFilePath: api.relativeFilePath,
      methods: api.methods,
      hasValidation: api.inputValidation,
      deps: api.dependencies
    }));
    const layoutInfoList = Object.values(this.layouts);
    return {
      framework: this.frameworkInfo,
      routerType: this.isAppRouter ? "app" : this.isPagesRouter ? "pages" : "unknown",
      stats: {
        fileCount: this.fileInfos.length,
        routeCount: this.pages.length,
        apiRouteCount: this.apis.length,
        layoutCount: Object.keys(this.layouts).length
      },
      layouts: layoutInfoList,
      routes: routeInfoList,
      apiRoutes: apiRouteInfoList,
      allPaths: this.paths
    };
  }
  getLayoutChainForPage(filepath) {
    const fileDirPath = path4.dirname(filepath);
    return Object.entries(this.layouts).map(([name, layout]) => ({
      name,
      relativeDirPath: layout.relativeDirPath,
      distance: this.getDirectoryDistance(
        fileDirPath,
        layout.relativeDirPath
      )
    })).filter((layout) => layout.distance >= 0).sort((a, b) => a.distance - b.distance).map((layout) => layout.name);
  }
  getDirectoryDistance(from, to) {
    if (!from.startsWith(to)) {
      return -1;
    }
    const fromParts = from.split("/");
    const toParts = to.split("/");
    return fromParts.length - toParts.length;
  }
  getHooksForFile(filepath) {
    const result = this.results.find((r) => r.path === filepath);
    return result?.details?.hooks || [];
  }
  getEventHandlersForFile(filepath) {
    const result = this.results.find((r) => r.path === filepath);
    return result?.details?.eventHandlers || [];
  }
  async saveAnalysisToFile(analysis) {
    try {
      await fs4.mkdir(this.cacheFrameworkDir, { recursive: true });
      const analysisJsonPath = path4.join(
        this.cacheFrameworkDir,
        "analysis.json"
      );
      const output = {
        metadata: {
          timestamp: Date.now(),
          version: this.NEXT_ANALYSIS_VERSION,
          git: await getGitInfo()
        },
        data: analysis
      };
      await fs4.writeFile(analysisJsonPath, JSON.stringify(output, null, 2));
      this.log.trace(`Analysis saved to ${analysisJsonPath}`);
    } catch (error) {
      this.log.error("Failed to save analysis to file", getErrorDetails(error));
      throw error;
    }
  }
  async parseFiles() {
    const fileExtensions = [".js", ".jsx", ".ts", ".tsx"];
    this.log.trace("Parsing eligible files", {
      extensions: fileExtensions
    });
    for (const ext of fileExtensions) {
      const files = this.fileInfos.filter((file) => file.extension === ext);
      this.log.trace(`Found ${files.length} files with extension: ${ext}`);
      for (const file of files) {
        try {
          if (!file.content) {
            try {
              this.log.trace("Reading file", { path: file.relativeFilePath });
              file.content = await fs4.readFile(
                path4.join(this.frameworkInfo.dirPath, file.relativeFilePath),
                "utf-8"
              );
            } catch (readError) {
              this.log.error(
                `Error reading file ${file.relativeFilePath}:`,
                getErrorDetails(readError)
              );
              continue;
            }
          }
          if (!file.ast && file.content) {
            try {
              const ast = parser.parse(file.content, {
                sourceType: "module",
                plugins: [
                  "jsx",
                  "typescript",
                  "classProperties",
                  "decorators-legacy",
                  "exportDefaultFrom",
                  "dynamicImport",
                  "optionalChaining",
                  "nullishCoalescingOperator"
                ]
              });
              file.ast = ast;
            } catch (parseError) {
              this.log.error(
                `Error parsing file ${file.relativeFilePath}:`,
                getErrorDetails(parseError)
              );
            }
          }
        } catch (error) {
          this.log.error(
            `Unexpected error processing file ${file.relativeFilePath}:`,
            getErrorDetails(error)
          );
        }
      }
    }
    this.log.trace("File parsing complete");
  }
  async processLayoutFiles() {
    const layoutFileInfos = this.fileInfos.filter(
      (file) => /^layout\.(jsx?|tsx)$/.test(file.name)
    );
    for (const layoutFileInfo of layoutFileInfos) {
      const ast = assertDefined(layoutFileInfo.ast);
      const content = assertDefined(layoutFileInfo.content);
      let componentFunctions = /* @__PURE__ */ new Map();
      let layoutName = null;
      traverse(ast, {
        // Collect all function declarations
        FunctionDeclaration(path11) {
          if (path11.node.id) {
            componentFunctions.set(path11.node.id.name, path11.node);
          }
        },
        // Try to find which one is exported
        ExportDefaultDeclaration(path11) {
          if (t.isFunctionDeclaration(path11.node.declaration) && path11.node.declaration.id) {
            layoutName = path11.node.declaration.id.name;
          } else if (t.isIdentifier(path11.node.declaration)) {
            layoutName = path11.node.declaration.name;
          } else if (t.isCallExpression(path11.node.declaration)) {
            let arg = path11.node.declaration.arguments[0];
            if (t.isIdentifier(arg)) {
              layoutName = arg.name;
            }
          }
        }
      });
      if (!layoutName && componentFunctions.size > 0) {
        layoutName = [...componentFunctions.keys()][0];
      }
      if (!layoutName) {
        this.log.error("Could not determine layout name", {
          path: layoutFileInfo.relativeFilePath
        });
        throw new ShortestError(
          `Could not determine layout name: ${layoutFileInfo.relativeFilePath}`
        );
      }
      const layoutInfo = {
        name: layoutName,
        relativeFilePath: layoutFileInfo.relativeFilePath,
        relativeDirPath: layoutFileInfo.relativeDirPath,
        content,
        components: this.extractComponentsFromAST(ast)
      };
      this.layouts[layoutName] = layoutInfo;
    }
  }
  detectRouterType() {
    this.isAppRouter = this.fileInfos.some(
      (file) => file.relativeDirPath === "app"
    );
    this.isPagesRouter = this.fileInfos.some(
      (file) => file.relativeDirPath === "pages"
    );
    if (this.isAppRouter && this.isPagesRouter) {
      this.log.debug(
        "Detected both App Router and Pages Router. Prioritizing App Router for analysis."
      );
    } else if (this.isAppRouter) {
      this.log.debug("Detected Next.js App Router");
    } else if (this.isPagesRouter) {
      this.log.debug("Detected Next.js Pages Router");
    } else {
      this.log.debug("Could not determine Next.js router type");
    }
  }
  async processRouteFiles() {
    this.log.trace("Processing route files", {
      isAppRouter: this.isAppRouter,
      isPagesRouter: this.isPagesRouter
    });
    const ROUTING_FILE_PATTERNS = [
      "layout\\.(js|jsx|tsx)$",
      "page\\.(js|jsx|tsx)$",
      "loading\\.(js|jsx|tsx)$",
      "not-found\\.(js|jsx|tsx)$",
      "error\\.(js|jsx|tsx)$",
      "global-error\\.(js|jsx|tsx)$",
      "route\\.(js|ts)$",
      "template\\.(js|jsx|tsx)$",
      "default\\.(js|jsx|tsx)$"
    ];
    const appRouterFiles = this.fileInfos.filter(
      (file) => ROUTING_FILE_PATTERNS.some(
        (pattern) => new RegExp(pattern).test(file.name)
      )
    );
    if (appRouterFiles.length > 0 || this.isAppRouter) {
      this.isAppRouter = true;
      this.log.debug(`Found ${appRouterFiles.length} App Router files`);
      for (const file of appRouterFiles) {
        await this.processAppRouterFile(file);
      }
    }
    const pagesFiles = this.fileInfos.filter((file) => {
      const isPagesFile = file.relativeDirPath.includes("/pages/") || file.relativeDirPath.startsWith("pages/");
      const isSpecialFile = file.name.startsWith("_") || file.name === "api";
      return isPagesFile && !isSpecialFile;
    });
    if (pagesFiles.length > 0 || this.isPagesRouter) {
      this.isPagesRouter = true;
      this.log.debug(`Found ${pagesFiles.length} Pages Router files`);
      for (const file of pagesFiles) {
        await this.processPagesRouterFile(file);
      }
    }
    const apiFiles = this.fileInfos.filter(
      (file) => file.relativeFilePath.includes("/api/")
    );
    this.log.debug(`Found ${apiFiles.length} API files`);
    for (const file of apiFiles) {
      if (file.relativeFilePath.startsWith("pages/api/")) {
        await this.processPagesRouterFile(file);
      } else {
        await this.processAppRouterFile(file);
      }
    }
    this.log.debug(
      `Processed ${this.routes.length} routes and ${this.apiRoutes.length} API routes`
    );
  }
  // TODO: Untested, AI-generated, check if this logic actually works
  async processAppRouterFile(file) {
    if (!file.content || !file.ast)
      return;
    const fileDetail = {
      framework: "next",
      path: file.relativeFilePath,
      details: {
        isRoute: false,
        isApiRoute: false,
        isLayout: false,
        components: [],
        imports: [],
        exports: [],
        hooks: [],
        eventHandlers: []
      }
    };
    fileDetail.details.imports = this.extractImportsFromAST(file.ast);
    fileDetail.details.exports = this.extractExportsFromAST(file.ast);
    fileDetail.details.hooks = this.extractHooksFromAST(file.ast);
    fileDetail.details.eventHandlers = this.extractEventHandlersFromAST(
      file.ast
    );
    fileDetail.details.components = this.extractComponentsFromAST(file.ast);
    if (file.name === "page.js" || file.name === "page.tsx") {
      fileDetail.details.isRoute = true;
      const routePath = this.getRoutePathFromFileApp(file.relativeFilePath);
      this.routes.push(routePath);
      const pageInfo = {
        routePath,
        relativeFilePath: file.relativeFilePath,
        components: fileDetail.details.components || [],
        hasParams: this.hasRouteParams(routePath),
        hasFormSubmission: this.hasFormSubmissionInAST(file.ast) || file.content.includes("onSubmit")
      };
      this.pages.push(pageInfo);
      fileDetail.details.pageInfo = pageInfo;
    } else if (file.name === "layout.js" || file.name === "layout.tsx") {
      fileDetail.details.isLayout = true;
      let layoutName;
      if (file.ast) {
        const exports = this.extractExportsFromAST(file.ast);
        const defaultExport = exports.find((e) => e.includes("default"));
        if (defaultExport) {
          layoutName = defaultExport.replace(" (default)", "");
        }
      }
      if (!layoutName) {
        const parts = file.relativeFilePath.split("/");
        const dirName = parts[parts.length - 2] || "";
        layoutName = dirName.charAt(0).toUpperCase() + dirName.slice(1) + "Layout";
      }
      if (file.relativeFilePath === "app/layout.tsx" || file.relativeFilePath === "app/layout.js") {
        layoutName = "RootLayout";
      }
    } else if (file.name === "route.js" || file.name === "route.tsx" || file.relativeFilePath.includes("/api/")) {
      fileDetail.details.isApiRoute = true;
      const routePath = this.getRoutePathFromFileApp(file.relativeFilePath);
      this.apiRoutes.push(routePath);
      const apiInfo = {
        routePath,
        relativeFilePath: file.relativeFilePath,
        methods: this.extractApiMethodsFromAST(file.ast),
        inputValidation: this.hasInputValidationInAST(file.ast),
        dependencies: fileDetail.details.imports || []
      };
      this.apis.push(apiInfo);
      fileDetail.details.apiInfo = apiInfo;
    }
    this.results.push(fileDetail);
  }
  async processPagesRouterFile(file) {
    if (!file.content || !file.ast)
      return;
    const fileDetail = {
      framework: "next",
      path: file.relativeFilePath,
      details: {
        isRoute: false,
        isApiRoute: false,
        components: [],
        imports: [],
        exports: [],
        hooks: [],
        eventHandlers: []
      }
    };
    fileDetail.details.imports = this.extractImportsFromAST(file.ast);
    fileDetail.details.exports = this.extractExportsFromAST(file.ast);
    fileDetail.details.hooks = this.extractHooksFromAST(file.ast);
    fileDetail.details.eventHandlers = this.extractEventHandlersFromAST(
      file.ast
    );
    fileDetail.details.components = this.extractComponentsFromAST(file.ast);
    if (file.name === "_app.js" || file.name === "_app.tsx") {
      this.layouts["PagesAppLayout"] = {
        name: "PagesAppLayout",
        relativeFilePath: file.relativeFilePath,
        relativeDirPath: file.relativeDirPath,
        content: file.content || "",
        components: this.extractComponentsFromAST(
          file.ast || parser.parse("", { sourceType: "module" })
        )
      };
    }
    if (file.relativeFilePath.startsWith("pages/api/")) {
      fileDetail.details.isApiRoute = true;
      const routePath = this.getRoutePathFromFilePages(file.relativeFilePath);
      this.apiRoutes.push(routePath);
      const apiInfo = {
        routePath,
        relativeFilePath: file.relativeFilePath,
        methods: this.extractApiMethodsFromAST(file.ast),
        inputValidation: this.hasInputValidationInAST(file.ast),
        dependencies: fileDetail.details.imports || []
      };
      this.apis.push(apiInfo);
      fileDetail.details.apiInfo = apiInfo;
    } else {
      fileDetail.details.isRoute = true;
      const routePath = this.getRoutePathFromFilePages(file.relativeFilePath);
      this.routes.push(routePath);
      const pageInfo = {
        routePath,
        relativeFilePath: file.relativeFilePath,
        components: fileDetail.details.components || [],
        hasParams: this.hasRouteParams(routePath),
        hasFormSubmission: this.hasFormSubmissionInAST(file.ast) || file.content.includes("onSubmit")
      };
      this.pages.push(pageInfo);
      fileDetail.details.pageInfo = pageInfo;
    }
    this.results.push(fileDetail);
  }
  extractImportsFromAST(ast) {
    const imports = [];
    traverse(ast, {
      ImportDeclaration(path11) {
        path11.node.specifiers.forEach((specifier) => {
          if (t.isImportSpecifier(specifier) && t.isIdentifier(specifier.imported)) {
            imports.push(specifier.imported.name);
          } else if (t.isImportDefaultSpecifier(specifier)) {
            imports.push(specifier.local.name);
          }
        });
      }
    });
    return imports;
  }
  extractExportsFromAST(ast) {
    const exports = [];
    traverse(ast, {
      ExportNamedDeclaration(path11) {
        if (path11.node.declaration) {
          if (t.isVariableDeclaration(path11.node.declaration)) {
            path11.node.declaration.declarations.forEach((declaration) => {
              if (t.isIdentifier(declaration.id)) {
                exports.push(declaration.id.name);
              }
            });
          } else if (t.isFunctionDeclaration(path11.node.declaration) && path11.node.declaration.id) {
            exports.push(path11.node.declaration.id.name);
          }
        }
      },
      ExportDefaultDeclaration(path11) {
        if (t.isFunctionDeclaration(path11.node.declaration) && path11.node.declaration.id) {
          exports.push(`${path11.node.declaration.id.name} (default)`);
        } else if (t.isIdentifier(path11.node.declaration)) {
          exports.push(`${path11.node.declaration.name} (default)`);
        } else {
          exports.push("(anonymous default export)");
        }
      }
    });
    return exports;
  }
  extractHooksFromAST(ast) {
    const hooks = [];
    traverse(ast, {
      CallExpression(path11) {
        if (t.isIdentifier(path11.node.callee)) {
          const name = path11.node.callee.name;
          if (name.startsWith("use") && /^use[A-Z]/.test(name)) {
            if (!hooks.includes(name)) {
              hooks.push(name);
            }
          }
        }
      }
    });
    return hooks;
  }
  extractEventHandlersFromAST(ast) {
    const handlers = [];
    traverse(ast, {
      VariableDeclarator(path11) {
        if (t.isIdentifier(path11.node.id)) {
          const name = path11.node.id.name;
          if (/^handle[A-Z]|on[A-Z]|[A-Za-z]+(Click|Change|Submit|Focus|Blur)$/.test(
            name
          )) {
            if (!handlers.includes(name)) {
              handlers.push(name);
            }
          }
        }
      },
      FunctionDeclaration(path11) {
        if (path11.node.id) {
          const name = path11.node.id.name;
          if (/^handle[A-Z]|on[A-Z]|[A-Za-z]+(Click|Change|Submit|Focus|Blur)$/.test(
            name
          )) {
            if (!handlers.includes(name)) {
              handlers.push(name);
            }
          }
        }
      }
    });
    return handlers;
  }
  extractComponentsFromAST(ast) {
    const components = [];
    traverse(ast, {
      JSXOpeningElement(path11) {
        const name = path11.node.name;
        if (t.isJSXIdentifier(name)) {
          if (t.isJSXIdentifier(name) && /^[A-Z]/.test(name.name) && !components.includes(name.name)) {
            components.push(name.name);
          }
        }
      }
    });
    return components;
  }
  hasFormSubmissionInAST(ast) {
    let hasFormSubmission = false;
    traverse(ast, {
      JSXOpeningElement(path11) {
        if (t.isJSXIdentifier(path11.node.name) && path11.node.name.name === "form") {
          hasFormSubmission = true;
        }
      },
      JSXAttribute(path11) {
        if (t.isJSXIdentifier(path11.node.name) && path11.node.name.name === "onSubmit") {
          hasFormSubmission = true;
        }
      },
      Identifier(path11) {
        if (path11.node.name === "handleSubmit") {
          hasFormSubmission = true;
        }
      }
    });
    return hasFormSubmission;
  }
  extractApiMethodsFromAST(ast) {
    const methods = [];
    traverse(ast, {
      MemberExpression(path11) {
        if (t.isIdentifier(path11.node.property)) {
          const propName = path11.node.property.name;
          if (["get", "post", "put", "delete", "patch"].includes(
            propName.toLowerCase()
          )) {
            const method = propName.toUpperCase();
            if (!methods.includes(method)) {
              methods.push(method);
            }
          }
        }
      },
      BinaryExpression(path11) {
        if (path11.node.operator === "===" || path11.node.operator === "==") {
          if (t.isMemberExpression(path11.node.left) && t.isIdentifier(path11.node.left.property) && path11.node.left.property.name === "method" && t.isStringLiteral(path11.node.right)) {
            const method = path11.node.right.value.toUpperCase();
            if (["GET", "POST", "PUT", "DELETE", "PATCH"].includes(method) && !methods.includes(method)) {
              methods.push(method);
            }
          }
        }
      }
    });
    return methods;
  }
  hasInputValidationInAST(ast) {
    let hasValidation = false;
    traverse(ast, {
      Identifier(path11) {
        const name = path11.node.name;
        if (["validate", "schema", "yup", "zod", "joi"].includes(name)) {
          hasValidation = true;
        }
      }
    });
    return hasValidation;
  }
  hasRouteParams(route) {
    return route.includes(":");
  }
  getRoutePathFromFileApp(filePath) {
    let routePath = filePath.replace(/^app/, "").replace(/\/(page|route|layout)\.(js|jsx|ts|tsx)$/, "");
    routePath = routePath.replace(/\/\[([^\]]+)\]/g, "/:$1");
    return routePath || "/";
  }
  getRoutePathFromFilePages(filePath) {
    let routePath = filePath.replace(/^pages/, "").replace(/\.(js|jsx|ts|tsx)$/, "");
    routePath = routePath.replace(/\/\[([^\]]+)\]/g, "/:$1");
    routePath = routePath.replace(/\/index$/, "");
    return routePath || "/";
  }
};

// src/core/framework-detector/index.ts
import { existsSync as existsSync2 } from "fs";
import fs5 from "fs/promises";
import path5 from "path";
import { listFrameworks } from "@netlify/framework-info";
var PROJECT_JSON_PATH = path5.join(
  DOT_SHORTEST_DIR_PATH,
  "project.json"
);
var getProjectInfo = async () => {
  const log = getLogger();
  try {
    return JSON.parse(await fs5.readFile(PROJECT_JSON_PATH, "utf-8"));
  } catch (error) {
    log.error("Failed to read cached project data", getErrorDetails(error));
    throw new ShortestError(
      "Failed to read cached project data, execute shortest detect-framework first"
    );
  }
};
var detectFramework = async (options = {}) => {
  const log = getLogger();
  if (!options.force && existsSync2(PROJECT_JSON_PATH)) {
    try {
      const projectInfo = JSON.parse(
        await fs5.readFile(PROJECT_JSON_PATH, "utf-8")
      );
      log.trace("Using cached framework information");
      return projectInfo;
    } catch (error) {
      log.trace(
        "Failed to read cached project data, performing detection",
        getErrorDetails(error)
      );
    }
  }
  let frameworks = [];
  let frameworkInfos = [];
  const nextJsDirPath = await detectNextJsDirPathFromConfig();
  if (nextJsDirPath) {
    frameworks = await listFrameworks({ projectDir: nextJsDirPath });
    frameworks.map((framework) => {
      frameworkInfos.push({
        id: framework.id,
        name: framework.name,
        dirPath: nextJsDirPath
      });
    });
  }
  log.trace("Frameworks detected", { frameworkInfos });
  await fs5.mkdir(DOT_SHORTEST_DIR_PATH, { recursive: true });
  try {
    const VERSION = 2;
    const projectInfo = {
      metadata: {
        timestamp: Date.now(),
        version: VERSION,
        git: await getGitInfo()
      },
      data: {
        frameworks: frameworkInfos
      }
    };
    await fs5.writeFile(
      PROJECT_JSON_PATH,
      JSON.stringify(projectInfo, null, 2),
      "utf-8"
    );
    log.info(`Saved project information to ${PROJECT_JSON_PATH}`);
    return projectInfo;
  } catch (error) {
    log.error("Failed to save project information", getErrorDetails(error));
    throw new ShortestError("Failed to save project information");
  }
};
var detectNextJsDirPathFromConfig = async () => {
  const log = getLogger();
  const paths = await getPaths(process.cwd());
  const nextDirConfigPaths = paths.filter((filePath) => /next\.config\.(js|ts|mjs|cjs)$/.test(filePath)).map((filePath) => path5.dirname(filePath));
  if (nextDirConfigPaths.length > 0) {
    log.trace("Detected Next.js config paths", { nextDirConfigPaths });
    const nextNamedDir = nextDirConfigPaths.find(
      (dirPath) => /next/i.test(dirPath)
    );
    return path5.join(process.cwd(), nextNamedDir || nextDirConfigPaths[0]);
  }
  return void 0;
};

// src/core/app-analyzer/index.ts
var SUPPORTED_FRAMEWORKS_IDS = ["next"];
var AppAnalyzer = class {
  frameworkInfo;
  log = getLogger();
  constructor(frameworkInfo) {
    this.frameworkInfo = frameworkInfo;
  }
  async execute(options = {}) {
    this.log.trace("Analyzing application...", {
      framework: this.frameworkInfo.id
    });
    let analysis;
    if (!options.force) {
      const existingAnalysis = await getExistingAnalysis(this.frameworkInfo.id);
      if (existingAnalysis) {
        this.log.trace("Using existing analysis from cache");
        return existingAnalysis;
      }
    }
    switch (this.frameworkInfo.id) {
      case "next":
        analysis = await this.analyzeNextJs();
        break;
      default:
        throw new ShortestError(
          `Unsupported framework: ${this.frameworkInfo.id}`
        );
    }
    this.log.trace(
      `Analysis complete for ${this.frameworkInfo.name} framework`
    );
    return analysis;
  }
  async analyzeNextJs() {
    this.log.trace("Starting Next.js analysis");
    try {
      const nextAnalyzer = new NextJsAnalyzer(this.frameworkInfo);
      const analysis = await nextAnalyzer.execute();
      this.log.trace("Next.js analysis completed successfully");
      return analysis;
    } catch (error) {
      this.log.error(
        "Failed to analyze Next.js application",
        getErrorDetails(error)
      );
      throw new ShortestError("Failed to analyze Next.js application");
    }
  }
};
var getExistingAnalysis = async (frameworkId) => {
  const log = getLogger();
  log.trace("Getting existing analysis", { frameworkId });
  try {
    const cacheFrameworkDir = path6.join(DOT_SHORTEST_DIR_PATH, frameworkId);
    const analysisJsonPath = path6.join(cacheFrameworkDir, "analysis.json");
    try {
      await fs6.access(analysisJsonPath);
    } catch {
      return null;
    }
    const analysisJson = await fs6.readFile(analysisJsonPath, "utf-8");
    const analysisData = JSON.parse(analysisJson);
    return analysisData.data;
  } catch (error) {
    log.trace("Failed to read existing analysis", getErrorDetails(error));
    return null;
  }
};
var detectSupportedFramework = async () => {
  const projectInfo = await getProjectInfo();
  const supportedFrameworks = projectInfo.data.frameworks.filter(
    (f) => SUPPORTED_FRAMEWORKS_IDS.includes(f.id)
  );
  if (supportedFrameworks.length === 0) {
    throw new ShortestError(`No supported framework found`);
  }
  if (supportedFrameworks.length > 1) {
    throw new ShortestError(
      `Multiple supported frameworks found: ${supportedFrameworks.map((f) => f.name).join(", ")}`
    );
  }
  return supportedFrameworks[0];
};

// src/cli/commands/analyze.ts
var analyzeCommand = new Command("analyze").description(
  "Analyze the structure of the project"
);
analyzeCommand.addOption(
  new Option("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).addOption(
  new Option("--force", "Force analysis even if cached data exists").default(
    false
  )
).action(async function() {
  await executeCommand(
    this.name(),
    this.optsWithGlobals(),
    async () => executeAnalyzeCommand(this.opts())
  );
}).showHelpAfterError("(add --help for additional information)");
var executeAnalyzeCommand = async (options = {}) => {
  const log = getLogger();
  const supportedFrameworkInfo = await detectSupportedFramework();
  log.info(`Analyzing ${supportedFrameworkInfo.name} application structure...`);
  const analyzer = new AppAnalyzer(supportedFrameworkInfo);
  const analysis = await analyzer.execute(options);
  log.info(
    `Analysis complete. Found ${analysis.stats.routeCount} routes, ${analysis.stats.apiRouteCount} API routes in ${analysis.stats.fileCount} files.`
  );
};

// src/cli/commands/cache.ts
import { Command as Command2, Option as Option2 } from "commander";
var cacheCommands = new Command2("cache").description(
  "Cache management commands"
);
var clearCommand = new Command2("clear").description(
  "Clear test cache"
);
clearCommand.option("--force-purge", "Force purge of all cache files", false).addOption(
  new Option2("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).action(async function() {
  await executeCommand(this.name(), this.optsWithGlobals(), async () => {
    await cleanUpCache({ forcePurge: this.opts().forcePurge });
  });
}).showHelpAfterError("(add --help for additional information)");
cacheCommands.addCommand(clearCommand);

// src/cli/commands/detect-framework.ts
import { Command as Command3, Option as Option3 } from "commander";
var detectFrameworkCommand = new Command3(
  "detect-framework"
).description("Detect the framework(s) of the current project");
detectFrameworkCommand.addOption(
  new Option3("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).addOption(
  new Option3("--force", "Force detection even if cached data exists").default(
    false
  )
).action(async function() {
  await executeCommand(
    this.name(),
    this.optsWithGlobals(),
    async () => executeDetectFrameworkCommand(this.opts())
  );
}).showHelpAfterError("(add --help for additional information)");
var executeDetectFrameworkCommand = async (options = {}) => {
  await detectFramework(options);
};

// src/cli/commands/generate.ts
import { Command as Command5, Option as Option5 } from "commander";

// src/core/test-generator/index.ts
import fs11 from "fs/promises";
import { createRequire as createRequire5 } from "module";
import path10 from "path";
import * as t2 from "@babel/types";

// src/cli/commands/shortest.ts
import { Command as Command4, Option as Option4 } from "commander";
import pc6 from "picocolors";

// src/constants.ts
var CONFIG_FILENAME = "shortest.config.ts";
var ENV_LOCAL_FILENAME = ".env.local";

// src/core/runner/index.ts
import { pathToFileURL } from "url";
import { glob } from "glob";
import * as playwright from "playwright";
import { request } from "playwright";

// src/ai/client.ts
import {
  generateText,
  NoSuchToolError
} from "ai";

// src/ai/prompts/index.ts
import os from "os";
var SYSTEM_PROMPT = `You are a test automation expert working with a Chrome browser.
You will be given test instructions, and your task is to execute specified browser actions to validate the provided test cases.
You are already in the Chrome browser and on the relevant application page, so there is no need to open or initialize the browser yourself.

EXAMPLE TEST CASE:
------------------
Test: "Log in to the app using GitHub login"
Context: {"username": "user@example.com","password": "secret"}
Callback function: [NO_CALLBACK]
Expect: 1. Test case to be generated within at least 20 seconds [HAS_CALLBACK]
------------------

IMPORTANT GLOBAL RULES:

1. **Waiting for Conditions**:
   - Always wait for the tool to finish before proceeding to the next action. You will recieve a message to continue with your next action once the wait is over. Then validate the condition is met.

2. **Tool Usage**:
   - You may need to use provided tools to perform certain actions (e.g., clicking, navigating, or running callbacks).
   - After invoking a tool, wait until the tool finishes its execution and you receive a success/failure result.
   - You will also receive metadata about the tool's execution to help you interpret its outcome.
   - Only after the tool finishes and you know the result should you request any screenshots or proceed to the next action.
   - Always include the "action" field matching the tool name in your tool calls (e.g. for "navigate" tool, include 'action: "navigate"').

3. **Screenshot Rule**:
   - Do not request screenshots until after a tool has completely finished its execution.
   - Once the tool execution result is received, you may then request a screenshot to determine subsequent actions if needed.

4. **GitHub Login Flow with 2FA**:
   - If you need to test a GitHub login flow that involves 2FA, only call the "github_login" tool after you have confirmed that the GitHub login page is displayed.
   - Calling the "github_login" tool prematurely (before the GitHub login page is visible) will lead to incorrect test behavior.

5. **Callbacks**:
   - Steps may include a notation like [HAS_CALLBACK], which means after completing the browser actions for that step, you must call the "run_callback" tool.

6. **Navigation Rule**:
   - Only use the "navigate" tool when explicitly specified in the test case instructions.
   - Do not use navigation based on intuition - follow test instructions exactly.
   - You must use the "navigate" tool as you don't have direct access to the browser search bar.
   - After navigation, verify the requested page is loaded by checking the URL in the metadata.

7. **Test Expectations**:
   - All expectations listed in the test instructions must be fulfilled.
   - If any expectation is not met, the test case must be marked as failed.

8. **Testing Email**:
   - If you need to test a condition that involves checking the contents of an email, use the "check_email" tool.
   - If no email address is given to you for this test, you must fail the test.
   - You MUST pass the email address that is given to you to the tool as a parameter, otherwise it will fail.
   - For email validation, you MUST always use 'Click' and 'Mouse' actions instead of keyboard shortcuts.

9. **Bash Commands**:
   - You have access to a bash tool to execute bash commands.
   - Only use tools typically available in a bash terminal, unless the prompt specifically instructs otherwise
   - When generating bash commands, ensure they are appropriate for the operating system you are currently using: ${os.platform()}.
   - If you are asked to generate bash command for API requests, you should make sure you replace placeholders (<>) in the request details with the actual values from memory or context.

Your task is to:
1. Execute browser actions to validate test cases
2. Use provided browser tools to interact with the page
3. Return test execution results in strict JSON format: { status: "passed" | "failed", reason: string }.
   For failures, provide a maximum 1-sentence reason.
   IMPORTANT:
   - DO NOT include anything else in your response, only the result and reason.
   - DO NOT include any other JSON-like object in your response except the required structure.
   - If there's need to do that, remove braces {} to ensure it's not interpreted as JSON.
4. For click actions, provide x,y coordinates of the element to click.`;

// src/ai/provider.ts
import { createAnthropic } from "@ai-sdk/anthropic";
var createProvider = (aiConfig) => {
  switch (aiConfig.provider) {
    case "anthropic":
      const anthropic5 = createAnthropic({ apiKey: aiConfig.apiKey });
      return anthropic5(aiConfig.model);
    default:
      throw new AIError(
        "unsupported-provider",
        `${aiConfig.provider} is not supported.`
      );
  }
};

// src/ai/utils/json.ts
var JSON_REGEX = /{[\s\S]*?}/g;
var aiJSONResponseSchema = z.object({
  status: z.enum(["passed", "failed"]),
  reason: z.string()
});
var extractJsonPayload = (response, schema = aiJSONResponseSchema) => {
  const jsonMatches = response.match(JSON_REGEX);
  if (!jsonMatches || jsonMatches.length === 0) {
    throw new AIError(
      "invalid-response",
      "AI didn't return the expected JSON payload."
    );
  }
  if (jsonMatches.length > 1) {
    throw new AIError(
      "invalid-response",
      "Ambiguous JSON: multiple JSON objects found."
    );
  }
  const jsonMatch = jsonMatches[0];
  try {
    const parsedJson = JSON.parse(jsonMatch);
    return schema.parse(parsedJson);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new AIError(
        "invalid-response",
        formatZodError(error, "Invalid AI response.")
      );
    }
    throw error;
  }
};

// src/index.ts
import { join as join2 } from "path";
import dotenv from "dotenv";
import { expect as jestExpect } from "expect";

// src/core/compiler/index.ts
import { mkdirSync, existsSync as existsSync3, writeFileSync } from "fs";
import { tmpdir } from "os";
import { join, resolve, basename } from "path";
import { build } from "esbuild";
var TestCompiler = class {
  cacheDir;
  defaultOptions = {
    format: "esm",
    platform: "node",
    target: "node18",
    sourcemap: true,
    bundle: true,
    external: [
      "shortest",
      "fs",
      "path",
      "os",
      "util",
      "events",
      "stream",
      "assert",
      "url",
      "crypto",
      "buffer",
      "querystring",
      "fsevents"
    ],
    banner: {
      js: `
        import { fileURLToPath } from 'url';
        import { dirname } from 'path';
        import { createRequire } from 'module';

        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        const require = createRequire(import.meta.url);
      `
    }
  };
  constructor() {
    this.cacheDir = join(tmpdir(), "shortest-cache");
    if (!existsSync3(this.cacheDir)) {
      mkdirSync(this.cacheDir, { recursive: true });
    }
  }
  async compileFile(filePath) {
    const fileName = basename(filePath).replace(".ts", ".mjs");
    const outputPath = join(this.cacheDir, fileName);
    const packageJson = {
      type: "module",
      imports: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      }
    };
    writeFileSync(
      join(this.cacheDir, "package.json"),
      JSON.stringify(packageJson)
    );
    await build({
      ...this.defaultOptions,
      entryPoints: [filePath],
      outfile: outputPath,
      alias: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      },
      resolveExtensions: [".ts", ".js", ".mjs"],
      banner: {
        js: `
          import { fileURLToPath } from 'url';
          import { dirname } from 'path';
          import { createRequire } from 'module';

          const __filename = fileURLToPath(import.meta.url);
          const __dirname = dirname(__filename);
          const require = createRequire(import.meta.url);
        `
      }
    });
    return outputPath;
  }
  async loadModule(filePath, cwd) {
    const absolutePath = resolve(cwd, filePath);
    if (!existsSync3(absolutePath)) {
      throw new ConfigError(
        "file-not-found",
        `Config file not found: ${filePath}`
      );
    }
    const result = await build({
      ...this.defaultOptions,
      entryPoints: [absolutePath],
      write: false,
      external: ["shortest"]
    });
    const code = result.outputFiles[0].text;
    const tempFile = join(this.cacheDir, "config.mjs");
    writeFileSync(tempFile, code);
    return import(`file://${tempFile}`);
  }
};

// src/utils/create-hash.ts
import crypto from "crypto";
var createHash = (data, options) => {
  const hash = crypto.createHash("sha256");
  const hashString = hash.update(JSON.stringify(data)).digest("hex");
  return options?.length ? hashString.slice(0, options.length) : hashString;
};

// src/core/runner/test-case.ts
var TestCaseFunctionSchema = z.function().args(z.custom()).returns(z.promise(z.void()));
var TestCaseExpectationsSchema = z.object({
  description: z.string().optional(),
  payload: z.any().optional(),
  fn: TestCaseFunctionSchema.optional(),
  directExecution: z.boolean().optional().default(false)
});
var TestCaseSchema = z.object({
  name: z.string(),
  filePath: z.string(),
  payload: z.any().optional(),
  fn: TestCaseFunctionSchema.optional(),
  expectations: z.array(TestCaseExpectationsSchema).default([]),
  beforeFn: TestCaseFunctionSchema.optional(),
  afterFn: TestCaseFunctionSchema.optional(),
  directExecution: z.boolean().optional().default(false),
  identifier: z.string().optional()
}).strict().transform((data) => {
  const hashInput = `${data.name}:${data.filePath}:${JSON.stringify(data.expectations)}`;
  return {
    ...data,
    // Low collision risk for datasets under 65,000 tests
    identifier: createHash(hashInput, { length: 8 })
  };
});
var createTestCase = (props) => {
  try {
    return {
      ...TestCaseSchema.parse(props)
    };
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ShortestError(formatZodError(error, "Invalid TestCase format"));
    }
    throw error;
  }
};

// src/types/ai.ts
var TokenUsageSchema = z.object({
  completionTokens: z.number().default(0),
  promptTokens: z.number().default(0),
  totalTokens: z.number().default(0)
});

// src/types/config.ts
var cliOptionsSchema = z.object({
  headless: z.boolean().optional(),
  baseUrl: z.string().optional().default("http://localhost:3000"),
  testPattern: z.string().optional().default("**/*.test.ts"),
  noCache: z.boolean().optional()
});
var ANTHROPIC_MODELS = [
  "claude-3-5-sonnet-20241022",
  "claude-3-5-sonnet-latest",
  "claude-3-7-sonnet-20250219",
  "claude-3-7-sonnet-latest"
];
var anthropicModelSchema = z.enum(ANTHROPIC_MODELS);
var aiSchema = z.object({
  provider: z.literal("anthropic"),
  apiKey: z.string().default(
    () => process.env[getShortestEnvName("ANTHROPIC_API_KEY")] || process.env.ANTHROPIC_API_KEY
  ),
  model: z.enum(ANTHROPIC_MODELS).default(ANTHROPIC_MODELS[0])
}).strict();
var cachingSchema = z.object({
  enabled: z.boolean().default(true)
}).strict();
var mailosaurSchema = z.object({
  apiKey: z.string(),
  serverId: z.string()
}).optional();
var testPatternSchema = z.string().default("**/*.test.ts");
var browserSchema = z.object({
  /**
   * @see https://playwright.dev/docs/api/class-browser#browser-new-context
   */
  contextOptions: z.custom().optional()
});
var configSchema = z.object({
  headless: z.boolean().default(true),
  baseUrl: z.string().url("must be a valid URL"),
  browser: browserSchema.strict().partial().default(browserSchema.parse({})),
  testPattern: testPatternSchema,
  anthropicKey: z.string().optional(),
  ai: aiSchema,
  mailosaur: mailosaurSchema.optional(),
  caching: cachingSchema.optional().default(cachingSchema.parse({}))
}).strict();
var userConfigSchema = configSchema.extend({
  browser: browserSchema.optional(),
  testPattern: testPatternSchema.optional(),
  ai: aiSchema.strict().partial().optional(),
  caching: cachingSchema.strict().partial().optional()
});
var SHORTEST_ENV_PREFIX = "SHORTEST_";
var getShortestEnvName = (key) => `${SHORTEST_ENV_PREFIX}${key}`;

// src/utils/config.ts
var parseConfig = (userConfig, cliOptions) => {
  const log = getLogger();
  try {
    let config;
    config = handleDeprecatedConfigOptions(userConfig);
    if (cliOptions) {
      config = handleCliOptions(config, cliOptions);
    }
    return configSchema.parse(config);
  } catch (error) {
    log.error("Error parsing config", { error });
    if (error instanceof z.ZodError) {
      throw new ConfigError(
        "invalid-config",
        formatZodError(error, "Invalid shortest.config")
      );
    }
    throw error;
  }
};
var handleDeprecatedConfigOptions = (userConfig) => {
  const log = getLogger();
  const deprecatedAnthropicKey = userConfig.anthropicKey;
  if (deprecatedAnthropicKey) {
    if (!userConfig.ai) {
      log.warn(
        "'config.anthropicKey' option is deprecated. Use 'config.ai' structure instead."
      );
      userConfig.ai = {
        provider: "anthropic",
        apiKey: deprecatedAnthropicKey
      };
    } else if (userConfig.ai.provider === "anthropic") {
      if (userConfig.ai.apiKey) {
        throw new ConfigError(
          "invalid-config",
          "'config.anthropicKey' conflicts with 'config.ai.apiKey'. Please remove 'config.anthropicKey'."
        );
      } else {
        log.warn(
          "'config.anthropicKey' option is deprecated. Please move it to 'config.ai.apiKey'."
        );
        userConfig.ai.apiKey = deprecatedAnthropicKey;
      }
    }
    delete userConfig.anthropicKey;
  }
  return userConfig;
};
var handleCliOptions = (userConfig, cliOptions) => {
  if (cliOptions.headless) {
    userConfig.headless = true;
  }
  if (cliOptions.baseUrl && cliOptions.baseUrl !== cliOptionsSchema.shape.baseUrl._def.defaultValue()) {
    userConfig.baseUrl = cliOptions.baseUrl;
  }
  if (cliOptions.testPattern && cliOptions.testPattern !== cliOptionsSchema.shape.testPattern._def.defaultValue()) {
    userConfig.testPattern = cliOptions.testPattern;
  }
  if (cliOptions.noCache) {
    if (userConfig.caching) {
      userConfig.caching.enabled = false;
    } else {
      userConfig.caching = { enabled: false };
    }
  }
  return userConfig;
};

// src/index.ts
var globalConfig = null;
var compiler = new TestCompiler();
if (!global.__shortest__) {
  global.__shortest__ = {
    expect: jestExpect,
    registry: {
      tests: /* @__PURE__ */ new Map(),
      currentFileTests: [],
      currentFilePath: "",
      beforeAllFns: [],
      afterAllFns: [],
      beforeEachFns: [],
      afterEachFns: [],
      directTestCount: 0
    }
  };
  global.expect = global.__shortest__.expect;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ENV_LOCAL_FILENAME) });
}
var initializeConfig = async ({
  cliOptions,
  configDir = process.cwd()
}) => {
  const log = getLogger();
  if (globalConfig) {
    return globalConfig;
  }
  log.trace("Initializing config");
  dotenv.config({ path: join2(configDir, ".env") });
  dotenv.config({ path: join2(configDir, ENV_LOCAL_FILENAME) });
  const configFiles = [
    CONFIG_FILENAME,
    CONFIG_FILENAME.replace(/\.ts$/, ".js"),
    CONFIG_FILENAME.replace(/\.ts$/, ".mjs")
  ];
  let configs = [];
  for (const file of configFiles) {
    try {
      const module = await compiler.loadModule(file, configDir);
      const userConfig = module.default;
      const parsedConfig = parseConfig(userConfig, cliOptions);
      configs.push({
        file,
        config: parsedConfig
      });
    } catch (error) {
      if (error instanceof ConfigError && error.type === "file-not-found") {
        continue;
      }
      throw error;
    }
  }
  if (configs.length === 0) {
    throw new ConfigError(
      "no-config",
      "No config file found. Please create one."
    );
  }
  if (configs.length > 1) {
    throw new ConfigError(
      "multiple-config",
      `Multiple config files found: ${configs.map((c) => c.file).join(", ")}. Please keep only one.`
    );
  }
  globalConfig = configs[0].config;
  log.debug("Config initialized", { globalConfig });
  return globalConfig;
};
var getConfig = () => {
  if (!globalConfig) {
    throw new ConfigError(
      "no-config",
      "Config not initialized. Call initializeConfig() first"
    );
  }
  return globalConfig;
};
var createTestChain = (nameOrFn, payloadOrFn, fn) => {
  const registry = global.__shortest__.registry;
  const normalizeName = (name2) => name2.replace(/\s+/g, " ").trim();
  if (Array.isArray(nameOrFn)) {
    const tests = nameOrFn.map((name2) => {
      const testCase2 = createTestCase({
        name: normalizeName(name2),
        filePath: registry.currentFilePath,
        expectations: []
      });
      const existingTests2 = registry.tests.get(name2) || [];
      registry.tests.set(name2, [...existingTests2, testCase2]);
      registry.currentFileTests.push(testCase2);
      return testCase2;
    });
    const lastTest = tests[tests.length - 1];
    if (!lastTest.name) {
      throw new ShortestError("Test name is required");
    }
    return createTestChain(lastTest.name, payloadOrFn, fn);
  }
  if (typeof nameOrFn === "function") {
    registry.directTestCount++;
    const testCase2 = createTestCase({
      name: `Direct Test #${registry.directTestCount}`,
      filePath: registry.currentFilePath,
      directExecution: true,
      fn: nameOrFn
    });
    registry.currentFileTests.push(testCase2);
    return {
      expect: () => {
        throw new ShortestError(
          "expect() cannot be called on direct execution test"
        );
      },
      after: () => {
        throw new ShortestError(
          "after() cannot be called on direct execution test"
        );
      },
      before: () => {
        throw new ShortestError(
          "before() cannot be called on direct execution test"
        );
      }
    };
  }
  const name = normalizeName(nameOrFn);
  const testCase = createTestCase({
    name,
    filePath: registry.currentFilePath,
    payload: typeof payloadOrFn === "function" ? void 0 : payloadOrFn,
    fn: typeof payloadOrFn === "function" ? payloadOrFn : fn,
    expectations: []
  });
  let existingTests = registry.tests.get(name) || [];
  registry.tests.set(name, [...existingTests, testCase]);
  registry.currentFileTests.push(testCase);
  const chain = {
    expect(descriptionOrFn, payloadOrFn2, fn2) {
      if (typeof descriptionOrFn === "function") {
        testCase.expectations.push({
          directExecution: true,
          fn: descriptionOrFn
        });
        return chain;
      }
      testCase.expectations ||= [];
      testCase.expectations.push({
        description: descriptionOrFn,
        payload: typeof payloadOrFn2 === "function" ? void 0 : payloadOrFn2,
        fn: typeof payloadOrFn2 === "function" ? payloadOrFn2 : fn2,
        directExecution: false
      });
      return chain;
    },
    before(fn2) {
      testCase.beforeFn = (context) => Promise.resolve(fn2(context));
      return chain;
    },
    after(fn2) {
      testCase.afterFn = (context) => Promise.resolve(fn2(context));
      return chain;
    }
  };
  return chain;
};
var test = Object.assign(
  (nameOrFn, payloadOrFn, fn) => createTestChain(nameOrFn, payloadOrFn, fn),
  {
    beforeAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeAllFns.push(hook);
    },
    afterAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterAllFns.push(hook);
    },
    beforeEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeEachFns.push(hook);
    },
    afterEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterEachFns.push(hook);
    }
  }
);

// src/ai/tools/anthropic/bash_20241022.ts
import { anthropic } from "@ai-sdk/anthropic";

// src/browser/core/bash-tool.ts
import { spawn } from "child_process";
var BashTool = class {
  log;
  constructor() {
    this.log = getLogger();
  }
  async execute(command) {
    return new Promise((resolve2, reject) => {
      const child = spawn(command, { shell: true });
      let output = "";
      let errorOutput = "";
      child.stdout.on("data", (data) => {
        output += data.toString();
      });
      child.stderr.on("data", (data) => {
        errorOutput += data.toString();
        if (this.getErrorType(data.toString()) === "timeout") {
          this.log.debug("Timeout error occurred, retrying...");
        }
      });
      child.on("exit", (code) => {
        if (code === 0) {
          resolve2(output.trim());
        } else {
          resolve2(
            errorOutput.trim() || `Process exited with code ${code ? code.toString() : "unknown"}`
          );
        }
      });
      child.on("error", (err) => {
        reject(`Error spawning process: ${err.message}`);
        throw asShortestError(err);
      });
    });
  }
  /**
   * Check the type of error from the provided stderr buffer
   * @param data Linux / PowerShell stderr buffer
   * @returns The type of error (e.g., "timeout", "network", etc)
   */
  getErrorType(data) {
    const unauthorizedRegex = /401 Unauthorized/i;
    if (unauthorizedRegex.test(data)) {
      return "unauthorized";
    }
    const timeoutRegex = /timeout|retrying in|request timed out/i;
    if (timeoutRegex.test(data)) {
      return "timeout";
    }
    const networkErrorRegex = /Could not resolve host|Name or service not known|connection refused|ENOTFOUND/i;
    if (networkErrorRegex.test(data)) {
      return "network";
    }
    return "unknown";
  }
};

// src/ai/tools/anthropic/bash_20241022.ts
var createAnthropicBash20241022 = () => anthropic.tools.bash_20241022({
  execute: async ({ command }) => await new BashTool().execute(command),
  experimental_toToolResultContent(result) {
    return [
      {
        type: "text",
        text: result
      }
    ];
  }
});

// src/ai/tools/anthropic/bash_20250124.ts
import { anthropic as anthropic2 } from "@ai-sdk/anthropic";
var createAnthropicBash20250124 = () => anthropic2.tools.bash_20250124({
  execute: async ({ command }) => await new BashTool().execute(command),
  experimental_toToolResultContent(result) {
    return [
      {
        type: "text",
        text: result
      }
    ];
  }
});

// src/ai/tools/anthropic/computer_20241022.ts
import { anthropic as anthropic3 } from "@ai-sdk/anthropic";
var createAnthropicComputer20241022 = (browserTool) => anthropic3.tools.computer_20241022({
  displayWidthPx: 1920,
  displayHeightPx: 1080,
  displayNumber: 0,
  execute: async (input2) => {
    const { action, ...restOfInput } = input2;
    const internalAction = actionMap[action];
    if (!internalAction) {
      const log = getLogger();
      log.error(`Computer action not supported`, {
        tool: "anthropic.computer_20241022",
        action
      });
      return { output: `Action '${action}' not supported` };
    }
    return browserTool.execute({ action: internalAction, ...restOfInput });
  },
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});
var actionMap = {
  key: "key" /* KEY */,
  type: "type" /* TYPE */,
  mouse_move: "mouse_move" /* MOUSE_MOVE */,
  left_click: "left_click" /* LEFT_CLICK */,
  left_click_drag: "left_click_drag" /* LEFT_CLICK_DRAG */,
  right_click: "right_click" /* RIGHT_CLICK */,
  middle_click: "middle_click" /* MIDDLE_CLICK */,
  double_click: "double_click" /* DOUBLE_CLICK */,
  screenshot: "screenshot" /* SCREENSHOT */,
  cursor_position: "cursor_position" /* CURSOR_POSITION */
};

// src/ai/tools/anthropic/computer_20250124.ts
import { anthropic as anthropic4 } from "@ai-sdk/anthropic";
var createAnthropicComputer20250124 = (browserTool) => anthropic4.tools.computer_20250124({
  displayWidthPx: 1920,
  displayHeightPx: 1080,
  displayNumber: 0,
  execute: async (input2) => {
    const { action, ...restOfInput } = input2;
    const internalAction = actionMap2[action];
    if (!internalAction) {
      const log = getLogger();
      log.error(`Computer action not supported`, {
        tool: "anthropic.computer_20250124",
        action
      });
      return { output: `Action '${action}' not supported` };
    }
    return browserTool.execute({ action: internalAction, ...restOfInput });
  },
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});
var actionMap2 = {
  key: "key" /* KEY */,
  hold_key: "hold_key" /* HOLD_KEY */,
  type: "type" /* TYPE */,
  cursor_position: "cursor_position" /* CURSOR_POSITION */,
  mouse_move: "mouse_move" /* MOUSE_MOVE */,
  left_mouse_down: "left_mouse_down" /* LEFT_MOUSE_DOWN */,
  left_mouse_up: "left_mouse_up" /* LEFT_MOUSE_UP */,
  left_click: "left_click" /* LEFT_CLICK */,
  left_click_drag: "left_click_drag" /* LEFT_CLICK_DRAG */,
  right_click: "right_click" /* RIGHT_CLICK */,
  middle_click: "middle_click" /* MIDDLE_CLICK */,
  double_click: "double_click" /* DOUBLE_CLICK */,
  triple_click: "triple_click" /* TRIPLE_CLICK */,
  scroll: "scroll" /* SCROLL */,
  wait: "wait" /* WAIT */,
  screenshot: "screenshot" /* SCREENSHOT */
};

// src/ai/tools/custom/check_email.ts
import { tool } from "ai";
var createCheckEmailTool = (browserTool) => tool({
  description: "View received email in new browser tab",
  parameters: z.object({
    action: z.literal("check_email"),
    email: z.string().describe("Email content or address to check for")
  }),
  execute: browserTool.execute.bind(browserTool),
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});

// src/ai/tools/custom/github_login.ts
import { tool as tool2 } from "ai";
var createGithubLoginTool = (browserTool) => tool2({
  description: "Handle GitHub OAuth login with 2FA",
  parameters: z.object({
    action: z.literal("github_login"),
    username: z.string(),
    password: z.string()
  }),
  execute: browserTool.execute.bind(browserTool),
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});

// src/ai/tools/custom/navigate.ts
import { tool as tool3 } from "ai";
var createNavigateTool = (browserTool) => tool3({
  description: "Navigate to URLs in new browser tab",
  parameters: z.object({
    action: z.literal("navigate"),
    url: z.string().url().describe("The URL to navigate to")
  }),
  execute: browserTool.execute.bind(browserTool),
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});

// src/ai/tools/custom/run_callback.ts
import { tool as tool4 } from "ai";
var createRunCallbackTool = (browserTool) => tool4({
  description: "Run callback function for current test step",
  parameters: z.object({
    action: z.literal("run_callback")
  }),
  execute: browserTool.execute.bind(browserTool),
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});

// src/ai/tools/custom/sleep.ts
import { tool as tool5 } from "ai";
var createSleepTool = (browserTool) => tool5({
  description: "Pause test execution for specified duration",
  parameters: z.object({
    action: z.literal("sleep"),
    duration: z.number().min(0).max(6e4)
  }),
  execute: browserTool.execute.bind(browserTool),
  experimental_toToolResultContent: browserTool.resultToToolResultContent
});

// src/tools/tool-registry.ts
var TOOL_ENTRY_CATEGORIES = ["provider", "custom"];
var toolEntryCategorySchema = z.enum(TOOL_ENTRY_CATEGORIES);
var toolFactoryNoArgSchema = z.function().args().returns(z.custom());
var toolFactoryWithArgSchema = z.function().args(z.custom()).returns(z.custom());
var toolFactorySchema = z.union([
  toolFactoryWithArgSchema,
  toolFactoryNoArgSchema
]);
var toolEntrySchema = z.union([
  z.object({
    name: z.literal("bash"),
    category: z.literal("provider"),
    factory: toolFactoryNoArgSchema
  }),
  z.object({
    name: z.string(),
    category: toolEntryCategorySchema,
    factory: toolFactoryWithArgSchema
  })
]);
var anthropicToolTypeSchema = z.enum(["computer", "bash"]);
var ANTHROPIC_MODEL_TO_FAMILY = {
  "claude-3-5-sonnet-latest": "claude-3-5",
  "claude-3-5-sonnet-20241022": "claude-3-5",
  "claude-3-7-sonnet-latest": "claude-3-7",
  "claude-3-7-sonnet-20250219": "claude-3-7"
};
var ANTHROPIC_TOOL_VERSION_MAP = {
  "claude-3-5": {
    computer: "20241022",
    bash: "20241022"
  },
  "claude-3-7": {
    computer: "20250124",
    bash: "20250124"
  }
};
var ToolRegistry = class {
  tools = /* @__PURE__ */ new Map();
  log;
  constructor() {
    this.log = getLogger();
  }
  /**
   * Registers a new tool with the registry
   *
   * @param key - Unique identifier for the tool
   * @param entry - Tool entry configuration
   * @throws Error if a tool with the same key is already registered
   */
  registerTool(key, entry) {
    if (this.tools.has(key)) {
      throw new Error(`Tool with key '${key}' already registered`);
    }
    this.tools.set(key, entry);
  }
  /**
   * Retrieves all tools for a specific provider and model
   *
   * @param provider - The provider name
   * @param model - The Anthropic model to get tools for
   * @param browserTool - Browser tool instance
   * @returns Record of tool name to Tool instance
   *
   * @private
   */
  getTools(provider, model, browserTool) {
    const selectedTools = {};
    const providerTools = this.getProviderTools(provider, model, browserTool);
    const customTools = this.getCustomTools(browserTool);
    Object.assign(selectedTools, providerTools, customTools);
    return selectedTools;
  }
  /**
   * Retrieves all custom tools
   *
   * @param browserTool - Browser tool instance
   * @returns Record of tool name to Tool instance
   *
   * @private
   */
  getCustomTools(browserTool) {
    const tools = {};
    const customTools = Array.from(this.tools.values()).filter(
      (entry) => entry.category === "custom"
    );
    customTools.forEach((entry) => {
      tools[entry.name] = entry.factory(browserTool);
    });
    return tools;
  }
  /**
   * Retrieves all provider-specific tools
   *
   * @param provider - The provider name
   * @param model - The Anthropic model to get tools for
   * @param browserTool - Browser tool instance
   * @returns Record of tool name to Tool instance
   *
   * @private
   */
  getProviderTools(provider, model, browserTool) {
    const tools = {};
    try {
      const computerToolEntry = this.getProviderToolEntry(
        provider,
        model,
        "computer"
      );
      tools[computerToolEntry.name] = computerToolEntry.factory(browserTool);
    } catch (error) {
      if (!(error instanceof ShortestError))
        throw error;
      this.log.trace("Computer tool not found for model, skipping", { model });
    }
    try {
      const bashToolEntry = this.getProviderToolEntry(provider, model, "bash");
      tools["bash"] = bashToolEntry.factory();
    } catch (error) {
      if (!(error instanceof ShortestError))
        throw error;
      this.log.trace("Bash tool not found for model, skipping", { model });
    }
    return tools;
  }
  /**
   * Retrieves a specific provider tool entry
   *
   * @param provider - The provider name
   * @param model - The Anthropic model
   * @param toolType - Type of tool to retrieve
   * @returns Tool entry configuration
   * @throws ShortestError if tool not found
   *
   * @private
   */
  getProviderToolEntry(provider, model, toolType) {
    const toolEntryKey = this.getToolEntryKey(provider, model, toolType);
    const toolEntry = this.tools.get(toolEntryKey);
    if (toolEntry) {
      return toolEntry;
    }
    throw new ShortestError(
      `${toolType} tool not found for key: ${toolEntryKey}`
    );
  }
  /**
   * Generates the key used to look up tool entries
   * @param provider - The provider name
   * @param model - The Anthropic model
   * @param toolType - Type of tool
   * @returns Tool entry key string
   *
   * @private
   */
  getToolEntryKey(provider, model, toolType) {
    const family = ANTHROPIC_MODEL_TO_FAMILY[model];
    const version = ANTHROPIC_TOOL_VERSION_MAP[family][toolType];
    return `${provider}_${toolType}_${version}`;
  }
};

// src/tools/index.ts
var toolToRegisterSchema = z.union([
  z.object({
    name: anthropicToolTypeSchema,
    category: z.literal("provider"),
    factory: toolFactorySchema
  }),
  z.object({
    name: z.string(),
    category: z.literal("custom"),
    factory: toolFactorySchema
  })
]);
var createToolRegistry = () => {
  const toolRegistry = new ToolRegistry();
  const toolsToRegister = {
    anthropic_computer_20241022: {
      name: "computer",
      category: "provider",
      factory: createAnthropicComputer20241022
    },
    anthropic_computer_20250124: {
      name: "computer",
      category: "provider",
      factory: createAnthropicComputer20250124
    },
    anthropic_bash_20241022: {
      name: "bash",
      category: "provider",
      factory: createAnthropicBash20241022
    },
    anthropic_bash_20250124: {
      name: "bash",
      category: "provider",
      factory: createAnthropicBash20250124
    },
    check_email: {
      name: "check_email",
      category: "custom",
      factory: createCheckEmailTool
    },
    github_login: {
      name: "github_login",
      category: "custom",
      factory: createGithubLoginTool
    },
    navigate: {
      name: "navigate",
      category: "custom",
      factory: createNavigateTool
    },
    run_callback: {
      name: "run_callback",
      category: "custom",
      factory: createRunCallbackTool
    },
    sleep: {
      name: "sleep",
      category: "custom",
      factory: createSleepTool
    }
  };
  Object.entries(toolsToRegister).forEach(([key, value]) => {
    toolRegistry.registerTool(key, value);
  });
  return toolRegistry;
};

// src/utils/sleep.ts
var sleep = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));

// src/ai/client.ts
var AIClient = class {
  client;
  browserTool;
  conversationHistory = [];
  testRun;
  log;
  usage;
  apiRequestCount = 0;
  toolRegistry;
  _tools = null;
  configAi;
  constructor({
    browserTool,
    testRun
  }) {
    this.log = getLogger();
    this.log.trace("Initializing AIClient");
    this.client = createProvider(getConfig().ai);
    this.configAi = getConfig().ai;
    this.browserTool = browserTool;
    this.testRun = testRun;
    this.usage = TokenUsageSchema.parse({});
    this.toolRegistry = createToolRegistry();
    this.log.trace(
      "Available tools",
      Object.fromEntries(
        Object.entries(this.tools).map(([name, tool6]) => [
          name,
          tool6.description || "No description"
        ])
      )
    );
  }
  /**
   * Retrieves or initializes the set of available tools for AI interactions.
   * Includes browser automation, bash execution, and specialized testing tools.
   *
   * @returns {Record<string, CoreTool>} Map of available tools
   *
   * @see {@link BrowserTool} for web automation tools
   * @see {@link BashTool} for shell command execution
   *
   * @private
   */
  get tools() {
    if (this._tools)
      return this._tools;
    this._tools = this.toolRegistry.getTools(
      this.configAi.provider,
      this.configAi.model,
      this.browserTool
    );
    return this._tools;
  }
  /**
   * Executes an AI action with retry logic and error handling.
   * Manages conversation flow and caches results for successful tests.
   *
   * @param {string} prompt - Input prompt for the AI
   * @returns {Promise<AIClientResponse>} Response with results and metadata
   * @throws {AIError} When max retries reached or non-retryable error occurs
   *
   * @example
   * ```typescript
   * const response = await client.runAction(
   *   "Click login button and verify redirect",
   * );
   * ```
   *
   * @private
   */
  async runAction(prompt) {
    const MAX_RETRIES = 3;
    let retries = 0;
    while (retries < MAX_RETRIES) {
      try {
        const result = await this.runConversation(prompt);
        if (!result) {
          throw new AIError("invalid-response", "No response received from AI");
        }
        return result;
      } catch (error) {
        this.log.error("Action failed", getErrorDetails(error));
        if (this.isNonRetryableError(error)) {
          throw asShortestError(error);
        }
        retries++;
        this.log.trace("Retry attempt", { retries, maxRetries: MAX_RETRIES });
        await sleep(5e3 * retries);
      }
    }
    throw new AIError("max-retries-reached", "Max retries reached");
  }
  /**
   * Manages conversation flow with the AI including tool execution and response handling.
   * Processes tool calls, updates conversation history, and validates responses.
   *
   * @param {string} prompt - Input prompt to start conversation
   * @returns {Promise<AIClientResponse | undefined>} Processed response
   * @throws {AIError} For invalid responses or tool execution failures
   *
   * @private
   */
  async runConversation(prompt) {
    const initialMessageOptions = { role: "user", content: prompt };
    this.conversationHistory.push(initialMessageOptions);
    this.log.trace("\u{1F4AC}", "New conversation message", initialMessageOptions);
    this.log.trace("\u{1F4AC}", "Conversation history initialized", {
      totalMessageCount: this.conversationHistory.length
    });
    while (true) {
      try {
        this.apiRequestCount++;
        this.log.setGroup(`${this.apiRequestCount}`);
        let resp;
        try {
          await sleep(1e3);
          this.log.trace("Calling generateText", {
            conversationMessageCount: this.conversationHistory.length
          });
          resp = await generateText({
            system: SYSTEM_PROMPT,
            model: this.client,
            maxTokens: 1024,
            tools: this.tools,
            messages: this.conversationHistory,
            onStepFinish: async (result) => {
              const isMouseMove = (args) => args.action === "mouse_move" && args.coordinate.length;
              for (const toolResult of result.toolResults) {
                let extras = {};
                if (isMouseMove(toolResult.args)) {
                  const [x, y] = toolResult.args.coordinate;
                  extras.componentStr = await this.browserTool.getNormalizedComponentStringByCoords(
                    x,
                    y
                  );
                }
                this.testRun.addStep({
                  reasoning: result.text,
                  action: {
                    name: toolResult.args.action,
                    input: toolResult.args,
                    type: "tool_use"
                  },
                  result: toolResult.result.output,
                  extras,
                  timestamp: Date.now()
                });
              }
            }
          });
        } catch (error) {
          this.log.error("Error making request", {
            error,
            fullError: JSON.stringify(error, null, 2),
            errorDetails: getErrorDetails(error)
          });
          if (NoSuchToolError.isInstance(error)) {
            this.log.error("Tool is not supported");
          }
          throw asShortestError(error);
        }
        this.log.trace("Request completed", {
          text: resp.text,
          finishReason: resp.finishReason,
          warnings: resp.warnings
        });
        this.updateUsage(resp.usage);
        resp.response.messages.forEach((message) => {
          this.log.trace("\u{1F4AC}", "New conversation message", {
            role: message.role,
            content: message.content
          });
          this.conversationHistory.push(message);
        });
        this.log.trace("\u{1F4AC}", "Conversation history updated", {
          newMessageCount: resp.response.messages.length,
          totalMessageCount: this.conversationHistory.length
        });
        this.throwOnErrorFinishReason(resp.finishReason);
        if (resp.finishReason === "tool-calls") {
          this.log.trace("tool-calls received as finish reason");
          continue;
        }
        try {
          const json = extractJsonPayload(resp.text);
          this.log.trace("Response", { ...json });
          return { response: json, metadata: { usage: this.usage } };
        } catch {
          throw new AIError(
            "invalid-response",
            "AI didn't return the expected JSON payload"
          );
        }
      } finally {
        this.log.resetGroup();
      }
    }
  }
  /**
   * Validates finish reason from language model and throws appropriate errors.
   * Handles token limits, content filtering, and other completion states.
   *
   * @param {LanguageModelV1FinishReason} reason - Completion finish reason
   * @throws {AIError} For invalid or error finish reasons
   *
   * @private
   */
  throwOnErrorFinishReason(reason) {
    const errorMap2 = {
      length: {
        message: "Generation stopped because the maximum token length was reached.",
        error: "token-limit-exceeded"
      },
      "content-filter": {
        message: "Content filter violation: generation aborted.",
        error: "unsafe-content-detected"
      },
      error: {
        message: "An error occurred during generation.",
        error: "unknown"
      },
      other: {
        message: "Generation stopped for an unknown reason.",
        error: "unknown"
      }
    };
    const errorInfo = errorMap2[reason];
    if (errorInfo) {
      throw new AIError(errorInfo.error, errorInfo.message);
    }
  }
  /**
   * Determines if an error should not be retried based on its status code.
   * Non-retryable errors include authentication, authorization, and server errors.
   *
   * @param {any} error - Error to evaluate
   * @returns {boolean} True if error should not be retried
   *
   * @private
   */
  isNonRetryableError(error) {
    return [401, 403, 500].includes(error.status);
  }
  /**
   * Updates token usage statistics with new usage data.
   * Tracks completion, prompt, and total token counts.
   *
   * @param {TokenUsage} usage - New usage data to add
   *
   * @private
   */
  updateUsage(usage) {
    this.usage.completionTokens += usage.completionTokens;
    this.usage.promptTokens += usage.promptTokens;
    this.usage.totalTokens += usage.totalTokens;
  }
};

// src/browser/core/browser-tool.ts
import * as fs7 from "fs/promises";
import { join as join3 } from "path";

// src/browser/actions/index.ts
var keyboardShortcuts = {
  "ctrl+l": ["Control", "l"],
  "ctrl+a": ["Control", "a"],
  "ctrl+c": ["Control", "c"],
  "ctrl+v": ["Control", "v"],
  "alt+tab": ["Alt", "Tab"],
  return: ["Enter"],
  enter: ["Enter"],
  esc: ["Escape"],
  tab: ["Tab"],
  delete: ["Delete"],
  backspace: ["Backspace"],
  space: [" "],
  arrowup: ["ArrowUp"],
  arrowdown: ["ArrowDown"],
  arrowleft: ["ArrowLeft"],
  arrowright: ["ArrowRight"],
  page_down: ["PageDown"],
  page_up: ["PageUp"]
};
var scaleRatio = {
  x: 1543 / 1170,
  y: 32 / 24
};
var mouseMove = async (page, x, y) => {
  if (!Number.isInteger(x) || !Number.isInteger(y) || x < 0 || y < 0) {
    throw new ToolError("Coordinates must be non-negative integers");
  }
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await page.mouse.move(scaledX, scaledY);
  await page.evaluate(
    ({ x: x2, y: y2 }) => {
      const cursor = document.getElementById("ai-cursor");
      const trail = document.getElementById("ai-cursor-trail");
      if (cursor && trail) {
        window.cursorPosition = { x: x2, y: y2 };
        cursor.style.left = `${x2}px`;
        cursor.style.top = `${y2}px`;
        setTimeout(() => {
          trail.style.left = `${x2}px`;
          trail.style.top = `${y2}px`;
        }, 50);
      }
    },
    { x: scaledX, y: scaledY }
  );
  await page.waitForTimeout(50);
};
var click = async (page, x, y, options = {
  button: "left",
  clickCount: 1
}) => {
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await mouseMove(page, x, y);
  const animationPromise = showClickAnimation(page, "left");
  await Promise.all([
    page.mouse.click(scaledX, scaledY, options),
    animationPromise
  ]);
};
var dragMouse = async (page, x, y) => {
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await page.mouse.down();
  await page.mouse.move(scaledX, scaledY);
  await page.mouse.up();
};
var showClickAnimation = async (page, type = "left") => page.evaluate(
  (clickType) => new Promise((resolve2) => {
    const cursor = document.getElementById("ai-cursor");
    if (!cursor)
      return resolve2(void 0);
    cursor.classList.add("clicking");
    switch (clickType) {
      case "double":
        cursor.style.transform = "translate(-50%, -50%) scale(0.7)";
        cursor.style.backgroundColor = "rgba(255, 0, 0, 0.5)";
        break;
      case "right":
        cursor.style.borderColor = "blue";
        break;
      default:
        cursor.style.transform = "translate(-50%, -50%) scale(0.8)";
    }
    setTimeout(() => {
      cursor.classList.remove("clicking");
      cursor.style.transform = "translate(-50%, -50%) scale(1)";
      cursor.style.backgroundColor = "rgba(255, 0, 0, 0.2)";
      cursor.style.borderColor = "red";
      resolve2(void 0);
    }, 200);
  }),
  type
);
var getCursorPosition = async (page) => {
  const position = await page.evaluate(
    () => window.cursorPosition || { x: 0, y: 0 }
  );
  return [position.x, position.y];
};

// src/browser/core/index.ts
var BaseBrowserTool = class {
  width;
  height;
  displayNum;
  screenshotDelay;
  toolType = "computer_20241022";
  toolName = "computer";
  constructor(options) {
    this.width = options.width;
    this.height = options.height;
    this.displayNum = options.displayNum || 1;
    this.screenshotDelay = options.screenshotDelay || 2e3;
  }
  validateCoordinates(x, y) {
    if (x < 0 || x > this.width || y < 0 || y > this.height) {
      throw new ToolError(`Coordinates (${x}, ${y}) out of bounds`);
    }
  }
  formatToolResult(output, error, base64_image, metadata) {
    return {
      output,
      error,
      base64_image,
      metadata
    };
  }
};

// src/browser/integrations/github.ts
import dotenv2 from "dotenv";
import { authenticator } from "otplib";
var GitHubTool = class {
  totpSecret;
  selectors = {
    loginForm: "#login form",
    usernameInput: "#login_field",
    passwordInput: "#password",
    submitButton: '[type="submit"]',
    useAuthenticatorButton: 'button:has-text("Use authenticator")',
    useAuthenticatorLink: '[data-test-selector="totp-app-link"]',
    otpInput: "#app_totp",
    errorMessage: ".flash-error"
  };
  constructor(secret) {
    dotenv2.config({ path: [".env", ENV_LOCAL_FILENAME] });
    this.totpSecret = secret || process.env.GITHUB_TOTP_SECRET || "";
    if (!this.totpSecret) {
      throw new ConfigError(
        "invalid-config",
        `GITHUB_TOTP_SECRET is required in ${ENV_LOCAL_FILENAME} file or via --secret option`
      );
    }
  }
  generateTOTPCode() {
    this.validateSecret();
    try {
      const code = authenticator.generate(this.totpSecret);
      const timeRemaining = authenticator.timeRemaining();
      return { code, timeRemaining };
    } catch (error) {
      throw new ShortestError(`Failed to generate TOTP code: ${error}`);
    }
  }
  async GithubLogin(browserTool, credentials) {
    try {
      await browserTool.waitForSelector(this.selectors.loginForm, {
        timeout: 1e4
      });
      await browserTool.fill(
        this.selectors.usernameInput,
        credentials.username
      );
      await browserTool.fill(
        this.selectors.passwordInput,
        credentials.password
      );
      await browserTool.click(this.selectors.submitButton);
      try {
        await browserTool.waitForSelector(
          this.selectors.useAuthenticatorButton,
          { timeout: 5e3 }
        );
        await browserTool.click(this.selectors.useAuthenticatorButton);
      } catch {
        await browserTool.waitForSelector(this.selectors.useAuthenticatorLink, {
          timeout: 5e3
        });
        await browserTool.click(this.selectors.useAuthenticatorLink);
      }
      await browserTool.waitForSelector(this.selectors.otpInput, {
        timeout: 1e3
      });
      const { code } = this.generateTOTPCode();
      await browserTool.fill(this.selectors.otpInput, code);
      const navigationPromise = browserTool.waitForNavigation({
        timeout: 3e3
      });
      await browserTool.press(this.selectors.otpInput, "Enter");
      await navigationPromise;
      const isLoggedIn = await browserTool.findElement(this.selectors.loginForm) === null;
      return {
        success: isLoggedIn,
        error: isLoggedIn ? void 0 : "Failed to verify login success"
      };
    } catch (error) {
      try {
        const currentUrl = await browserTool.getPage().url();
        if (!currentUrl.includes("github.com")) {
          return {
            success: true
          };
        }
      } catch {
      }
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error during GitHub login"
      };
    }
  }
  validateSecret() {
    if (!this.totpSecret) {
      throw new ConfigError(
        "invalid-config",
        `GITHUB_TOTP_SECRET is required in ${ENV_LOCAL_FILENAME} file or via --secret option`
      );
    }
  }
};

// src/browser/integrations/mailosaur.ts
import Mailosaur from "mailosaur";
var MailosaurTool = class {
  client;
  serverId;
  emailAddress;
  constructor(config) {
    this.client = new Mailosaur(config.apiKey);
    this.serverId = config.serverId;
    this.emailAddress = config.emailAddress;
  }
  async getLatestEmail() {
    try {
      const message = await this.client.messages.get(this.serverId, {
        sentTo: this.emailAddress
      });
      if (!message.html?.body || !message.text?.body) {
        throw new ToolError("Email content missing");
      }
      return {
        subject: message.subject || "No Subject",
        html: message.html.body,
        text: message.text.body
      };
    } catch (error) {
      throw new ToolError(`Mailosaur API error: ${error}`);
    }
  }
};

// src/browser/core/browser-tool.ts
var BrowserTool = class extends BaseBrowserTool {
  toolType = "computer_20241022";
  toolName = "computer";
  page;
  browserManager;
  cursorVisible = true;
  lastMousePosition = [0, 0];
  githubTool;
  viewport;
  testContext;
  MAX_SCREENSHOTS = 10;
  MAX_AGE_HOURS = 5;
  mailosaurTool;
  config;
  log;
  constructor(page, browserManager, config) {
    super(config);
    this.page = page;
    this.browserManager = browserManager;
    this.viewport = { width: config.width, height: config.height };
    this.testContext = config.testContext;
    this.log = getLogger();
    this.page.context().on("page", async (newPage) => {
      this.log.trace("Update active page reference to a newly opened tab");
      await newPage.waitForLoadState("domcontentloaded").catch(() => {
      });
      this.page = newPage;
    });
    this.initialize();
  }
  async click(selector) {
    this.log.debug("Clicking element", { selector });
    await this.page.click(selector);
  }
  async execute(input2) {
    try {
      this.log.setGroup(`\u{1F6E0}\uFE0F ${input2.action}`);
      let output = "";
      let metadata = {};
      switch (input2.action) {
        case "left_click" /* LEFT_CLICK */:
        case "right_click" /* RIGHT_CLICK */:
        case "middle_click" /* MIDDLE_CLICK */:
        case "double_click" /* DOUBLE_CLICK */:
        case "triple_click" /* TRIPLE_CLICK */: {
          const clickCoords = input2.coordinate || input2.coordinates || this.lastMousePosition;
          const x = clickCoords[0];
          const y = clickCoords[1];
          const button = () => {
            switch (input2.action) {
              case "left_click" /* LEFT_CLICK */:
              case "double_click" /* DOUBLE_CLICK */:
              case "triple_click" /* TRIPLE_CLICK */:
                return "left";
              case "right_click" /* RIGHT_CLICK */:
                return "right";
              case "middle_click" /* MIDDLE_CLICK */:
                return "middle";
              default:
                throw new ToolError(
                  `Unsupported click action: ${input2.action}`
                );
            }
          };
          const clickCount = () => {
            switch (input2.action) {
              case "double_click" /* DOUBLE_CLICK */:
                return 2;
              case "triple_click" /* TRIPLE_CLICK */:
                return 3;
              default:
                return 1;
            }
          };
          this.log.debug("Clicking at coordinates", {
            x,
            y,
            button: button(),
            clickCount: clickCount()
          });
          await click(this.page, x, y, {
            button: button(),
            clickCount: clickCount()
          });
          output = `${input2.action} at (${clickCoords[0]}, ${clickCoords[1]})`;
          metadata = await this.getMetadata();
          await this.page.waitForTimeout(100);
          if (await this.page.evaluate(() => document.readyState !== "complete").catch(() => true)) {
            try {
              await this.page.waitForLoadState("domcontentloaded", {
                timeout: 5e3
              });
              metadata = await this.getMetadata();
            } catch {
            }
          }
          break;
        }
        case "mouse_move" /* MOUSE_MOVE */:
          const coords = input2.coordinates || input2.coordinate;
          if (!coords) {
            throw new ToolError("Coordinates required for mouse_move");
          }
          await mouseMove(this.page, coords[0], coords[1]);
          this.lastMousePosition = [coords[0], coords[1]];
          output = `Mouse moved to (${coords[0]}, ${coords[1]})`;
          break;
        case "left_click_drag" /* LEFT_CLICK_DRAG */:
          if (!input2.coordinates) {
            throw new ToolError("Coordinates required for left_click_drag");
          }
          await dragMouse(
            this.page,
            input2.coordinates[0],
            input2.coordinates[1]
          );
          output = `Dragged mouse to (${input2.coordinates[0]}, ${input2.coordinates[1]})`;
          break;
        case "left_mouse_down" /* LEFT_MOUSE_DOWN */:
          await this.page.mouse.down();
          output = "Pressed left mouse button";
          break;
        case "left_mouse_up" /* LEFT_MOUSE_UP */:
          await this.page.mouse.up();
          output = "Released left mouse button";
          break;
        case "cursor_position" /* CURSOR_POSITION */:
          const position = await getCursorPosition(this.page);
          output = `Cursor position: (${position[0]}, ${position[1]})`;
          break;
        case "screenshot" /* SCREENSHOT */:
          return await this.takeScreenshotWithMetadata();
        case "type" /* TYPE */:
          if (!input2.text) {
            throw new ToolError("Text required for type action");
          }
          await this.page.waitForTimeout(100);
          await this.page.keyboard.type(input2.text);
          await this.page.waitForTimeout(100);
          output = `Typed: ${input2.text}`;
          break;
        case "key" /* KEY */: {
          if (!input2.text) {
            throw new ToolError("Key required for key action");
          }
          await this.page.waitForTimeout(100);
          const keyText = input2.text.toLowerCase();
          const keys = Array.isArray(keyboardShortcuts[keyText]) ? keyboardShortcuts[keyText] : [keyboardShortcuts[keyText] || input2.text];
          if (Array.isArray(keys)) {
            for (const key of keys) {
              await this.page.keyboard.down(key);
            }
            for (const key of [...keys].reverse()) {
              await this.page.keyboard.up(key);
            }
          } else {
            await this.page.keyboard.press(keys);
          }
          await this.page.waitForTimeout(100);
          output = `Pressed key: ${input2.text}`;
          break;
        }
        case "hold_key" /* HOLD_KEY */: {
          if (!input2.text) {
            throw new ToolError("Key required for hold_key action");
          }
          if (!input2.duration) {
            throw new ToolError("Duration required for hold_key action");
          }
          const seconds2 = input2.duration;
          const delay = seconds2 / 1e3;
          const keyText = input2.text.toLowerCase();
          const keys = Array.isArray(keyboardShortcuts[keyText]) ? keyboardShortcuts[keyText] : [keyboardShortcuts[keyText] || input2.text];
          const parsedKeys = keys.join("+");
          await this.page.keyboard.press(parsedKeys, { delay });
          output = `Held key: ${parsedKeys} for ${seconds2} second${seconds2 !== 1 ? "s" : ""}`;
          break;
        }
        case "github_login" /* GITHUB_LOGIN */: {
          if (!this.githubTool) {
            this.githubTool = new GitHubTool();
          }
          const loginResult = await this.githubTool.GithubLogin(this, {
            username: input2.username,
            password: input2.password
          });
          output = loginResult.success ? "GitHub login was successfully completed" : `GitHub login failed: ${loginResult.error}`;
          break;
        }
        case "clear_session" /* CLEAR_SESSION */:
          const newContext = await this.browserManager.recreateContext();
          this.page = newContext.pages()[0] || await newContext.newPage();
          await this.page.evaluate(() => {
            localStorage.clear();
            sessionStorage.clear();
          });
          return {
            output: "Successfully cleared browser data and created new context",
            metadata: {}
          };
        case "run_callback" /* RUN_CALLBACK */: {
          const testContext = this.testContext;
          const testCase = testContext.testRun.testCase;
          const currentStepIndex = testContext.currentStepIndex ?? 0;
          try {
            if (currentStepIndex === 0 && testCase.fn) {
              await testCase.fn(testContext);
              testContext.currentStepIndex = 1;
              return { output: "Test function executed successfully" };
            }
            const expectationIndex = currentStepIndex - 1;
            const expectation = testCase.expectations?.[expectationIndex];
            if (expectation?.fn) {
              await expectation.fn(this.testContext);
              testContext.currentStepIndex = currentStepIndex + 1;
              return {
                output: `Callback function for "${expectation.description}" passed successfully`
              };
            }
            return {
              output: `Skipping callback execution: No callback function defined for expectation "${expectation?.description}"`
            };
          } catch (error) {
            if (error && error.matcherResult) {
              const assertionError = error;
              throw new TestError("assertion-failed", assertionError.message, {
                actual: assertionError.matcherResult.actual,
                expected: assertionError.matcherResult.expected
              });
            }
            throw new TestError(
              "callback-execution-failed",
              error instanceof Error ? error.message : String(error)
            );
          }
        }
        case "navigate" /* NAVIGATE */: {
          if (!input2.url) {
            throw new ToolError("URL required for navigation");
          }
          this.log.trace("Creating new tab");
          const newPage = await this.page.context().newPage();
          try {
            const navigationTimeout = 3e4;
            this.log.trace("Navigating to", { url: input2.url });
            await newPage.goto(input2.url, {
              timeout: navigationTimeout,
              waitUntil: "domcontentloaded"
            });
            await newPage.waitForLoadState("load", {
              timeout: 5e3
            }).catch((error) => {
              this.log.debug("\u26A0\uFE0F", "Load timeout, continuing anyway", {
                error
              });
            });
            this.page = newPage;
            output = `Navigated to ${input2.url}`;
            metadata = {
              window_info: {
                url: input2.url,
                title: await newPage.title(),
                size: this.page.viewportSize() || {
                  width: this.width,
                  height: this.height
                }
              }
            };
            this.log.trace("Navigation completed", metadata);
            break;
          } catch (error) {
            await newPage.close();
            throw new ToolError(`Navigation failed: ${error}`);
          }
        }
        case "wait" /* WAIT */:
          if (!input2.duration) {
            throw new ToolError("Duration required for wait action");
          }
          const seconds = input2.duration;
          await this.page.waitForTimeout(seconds * 1e3);
          output = `Waited for ${seconds} second${seconds !== 1 ? "s" : ""}`;
          break;
        case "scroll" /* SCROLL */:
          if (!input2.coordinate || !input2.scroll_amount || !input2.scroll_direction) {
            throw new ToolError("Missing args for scroll action");
          }
          await this.page.mouse.move(input2.coordinate[0], input2.coordinate[1]);
          const deltaX = (input2.scroll_direction === "up" ? -input2.scroll_amount : input2.scroll_amount) || 0;
          const deltaY = (input2.scroll_direction === "left" ? -input2.scroll_amount : input2.scroll_amount) || 0;
          await this.page.mouse.wheel(deltaX, deltaY);
          output = `Scrolled ${input2.scroll_amount} clicks ${input2.scroll_direction}`;
          break;
        case "sleep" /* SLEEP */: {
          const defaultDuration = 1e3;
          const maxDuration = 6e4;
          let duration = input2.duration ?? defaultDuration;
          if (duration > maxDuration) {
            this.log.debug(
              `Requested sleep duration ${duration}ms exceeds maximum of ${maxDuration}ms. Using maximum.`
            );
            duration = maxDuration;
          }
          const seconds2 = Math.round(duration / 1e3);
          this.log.debug("\u23F3", "Waiting ...", { seconds: seconds2 });
          await this.page.waitForTimeout(duration);
          output = `Finished waiting for ${seconds2} second${seconds2 !== 1 ? "s" : ""}`;
          break;
        }
        case "check_email" /* CHECK_EMAIL */: {
          if (!this.mailosaurTool) {
            const mailosaurAPIKey = this.config.mailosaur?.apiKey || process.env.MAILOSAUR_API_KEY;
            const mailosaurServerId = this.config.mailosaur?.serverId || process.env.MAILOSAUR_SERVER_ID;
            if (!mailosaurAPIKey) {
              return {
                output: "Mailosaur API key is required",
                error: "MAILOSAUR_CONFIG_ERROR"
              };
            }
            if (!mailosaurServerId) {
              return {
                output: "Mailosaur server ID is required",
                error: "MAILOSAUR_CONFIG_ERROR"
              };
            }
            if (!input2.email) {
              return {
                output: "Mailosaur email address is required",
                error: "MAILOSAUR_CONFIG_ERROR"
              };
            }
            this.mailosaurTool = new MailosaurTool({
              apiKey: mailosaurAPIKey,
              serverId: mailosaurServerId,
              emailAddress: input2.email
            });
          }
          const newPage = await this.page.context().newPage();
          try {
            const email = await this.mailosaurTool.getLatestEmail();
            await newPage.setContent(email.html, {
              waitUntil: "domcontentloaded"
            });
            await newPage.waitForLoadState("load", {
              timeout: 5e3
            }).catch((error) => {
              this.log.debug("\u26A0\uFE0F", "Load timeout, continuing anyway", {
                error
              });
            });
            this.page = newPage;
            output = `Email received successfully. Navigated to new tab to display email: ${email.subject}`;
            metadata = {
              window_info: {
                title: email.subject,
                content: email.html,
                size: this.page.viewportSize() || {
                  width: this.width,
                  height: this.height
                }
              }
            };
            break;
          } catch (error) {
            await newPage.close();
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (errorMessage.includes("Email content missing")) {
              return {
                output: `Email was found but content is missing. This might be due to malformed email. Moving to next test.`,
                error: "EMAIL_CONTENT_MISSING"
              };
            }
            if (errorMessage.includes("Mailosaur email address is required")) {
              return {
                output: `Email address is required but was not provided.`,
                error: "EMAIL_ADDRESS_MISSING"
              };
            }
            if (errorMessage.includes("No matching messages found")) {
              return {
                output: `No email found for ${input2.email}. The email might not have been sent yet or is older than 1 hour. Moving to next test.`,
                error: "EMAIL_NOT_FOUND"
              };
            }
            return {
              output: `Failed to fetch or render email: ${errorMessage}. Moving to next test.`,
              error: "EMAIL_OPERATION_FAILED"
            };
          }
        }
        default:
          throw new ToolError(`Unknown action: ${input2.action}`);
      }
      try {
        await this.page.waitForTimeout(200);
        metadata = await this.getMetadata();
      } catch (metadataError) {
        this.log.debug("Failed to get metadata:", { metadataError });
        metadata = {};
      }
      return {
        output,
        metadata
      };
    } catch (error) {
      this.log.error("Browser action failed", getErrorDetails(error));
      if (error instanceof TestError && error.type === "assertion-failed") {
        return {
          output: `Assertion failed: ${error.message}${error.actual !== void 0 ? `
Expected: ${error.expected}
Received: ${error.actual}` : ""}`
        };
      }
      if (error instanceof TestError && error.type === "callback-execution-failed") {
        return {
          output: `Callback execution failed: ${error.message}`
        };
      }
      throw new ToolError(`Action failed: ${error}`);
    } finally {
      this.log.resetGroup();
    }
  }
  /**
   * Converts browser tool execution results to standardized content format.
   * Handles image data and text output formatting.
   *
   * @param {ToolResult} result - Raw tool execution result
   * @returns {Array<{type: string, data?: string, text?: string, mimeType?: string}>} Formatted content
   *
   * @private
   */
  resultToToolResultContent(result) {
    return result.base64_image ? [
      {
        type: "image",
        data: result.base64_image,
        mimeType: "image/jpeg"
      }
    ] : [
      {
        type: "text",
        text: result.output
      }
    ];
  }
  toToolParameters() {
    return {
      type: this.toolType,
      name: this.toolName,
      display_width_px: this.width,
      display_height_px: this.height,
      display_number: this.displayNum
    };
  }
  // Selector-based methods
  async waitForSelector(selector, options) {
    this.log.debug("Waiting for selector", { selector });
    await this.page.waitForSelector(selector, options);
  }
  async fill(selector, value) {
    this.log.debug("Filling element", { selector, value });
    await this.page.fill(selector, value);
  }
  async press(selector, key) {
    this.log.debug("Pressing key on element", { key, element: selector });
    await this.page.press(selector, key);
  }
  async findElement(selector) {
    this.log.debug("Finding element", { selector });
    return this.page.$(selector);
  }
  getPage() {
    return this.page;
  }
  async waitForNavigation(options) {
    this.log.debug("Waiting for navigation");
    await this.page.waitForLoadState("load", { timeout: options?.timeout });
  }
  updateTestContext(newContext) {
    this.testContext = newContext;
  }
  async showCursor() {
    this.cursorVisible = true;
    await this.page.evaluate(() => {
      const cursor = document.getElementById("ai-cursor");
      const trail = document.getElementById("ai-cursor-trail");
      if (cursor)
        cursor.style.display = "block";
      if (trail)
        trail.style.display = "block";
    });
  }
  async hideCursor() {
    this.cursorVisible = false;
    await this.page.evaluate(() => {
      const cursor = document.getElementById("ai-cursor");
      const trail = document.getElementById("ai-cursor-trail");
      if (cursor)
        cursor.style.display = "none";
      if (trail)
        trail.style.display = "none";
    });
  }
  /**
   * Retrieves normalized component string by X and Y coordinates
   * This is primarily used to determine change in UI
   * Playwright currently does not support such functionality
   * @see https://github.com/microsoft/playwright/issues/13273
   */
  async getNormalizedComponentStringByCoords(x, y) {
    return await this.getPage().evaluate(
      ({ x: x2, y: y2, allowedAttr }) => {
        const elem = document.elementFromPoint(x2, y2);
        if (elem) {
          const clone = elem.cloneNode(true);
          const getDeepestChildNode = (element) => {
            let deepestChild = element.cloneNode(true);
            let maxDepth = 0;
            const traverse4 = (node2, depth) => {
              if (depth > maxDepth) {
                maxDepth = depth;
                deepestChild = node2;
              }
              Array.from(node2.children).forEach((child) => {
                traverse4(child, depth + 1);
              });
            };
            traverse4(deepestChild, 0);
            return deepestChild;
          };
          const deepestNode = getDeepestChildNode(clone);
          const node = deepestNode.parentElement ? deepestNode.parentElement.parentElement ? deepestNode.parentElement.parentElement : deepestNode.parentElement : deepestNode;
          const cleanAttributesRecursively = (element, options) => {
            Array.from(element.attributes).forEach((attr) => {
              if (!options.exceptions.includes(attr.name)) {
                element.removeAttribute(attr.name);
              }
            });
            Array.from(element.children).forEach((child) => {
              cleanAttributesRecursively(child, options);
            });
          };
          cleanAttributesRecursively(node, {
            exceptions: allowedAttr
          });
          return node.outerHTML.trim().replace(/\s+/g, " ");
        }
        return "";
      },
      {
        x,
        y,
        allowedAttr: [
          "type",
          "name",
          "placeholder",
          "aria-label",
          "role",
          "title",
          "alt",
          "d"
          // for <path> tags
        ]
      }
    );
  }
  async initialize() {
    await initializeConfig({});
    this.config = getConfig();
    const initWithRetry = async () => {
      for (let i = 0; i < 3; i++) {
        try {
          await this.initializeCursor();
          break;
        } catch (error) {
          this.log.debug("Cursor initialization failed", {
            attempt: i + 1,
            maxAttempts: 3,
            error
          });
          await new Promise((resolve2) => setTimeout(resolve2, 100));
        }
      }
    };
    await initWithRetry();
    this.page.on("load", async () => {
      this.log.trace("Re-initialize on navigation");
      await initWithRetry();
    });
  }
  async initializeCursor() {
    try {
      await this.page.waitForLoadState("domcontentloaded", { timeout: 1e3 }).catch(() => {
      });
      const hasStyles = await this.page.evaluate(() => !!document.querySelector("style[data-shortest-cursor]")).catch(() => false);
      if (!hasStyles) {
        await this.page.evaluate(() => {
          const style = document.createElement("style");
          style.setAttribute("data-shortest-cursor", "true");
          style.textContent = `
            #ai-cursor {
              width: 20px;
              height: 20px;
              border: 2px solid red;
              border-radius: 50%;
              position: fixed;
              pointer-events: none;
              z-index: 999999;
              transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
              transform: translate(-50%, -50%);
              background-color: rgba(255, 0, 0, 0.2);
            }
            #ai-cursor.clicking {
              transform: translate(-50%, -50%) scale(0.8);
              background-color: rgba(255, 0, 0, 0.4);
            }
            #ai-cursor-trail {
              width: 8px;
              height: 8px;
              border-radius: 50%;
              position: fixed;
              pointer-events: none;
              z-index: 999998;
              background-color: rgba(255, 0, 0, 0.1);
              transition: all 0.1s linear;
              transform: translate(-50%, -50%);
            }
          `;
          document.head.appendChild(style);
        });
      }
      await this.page.evaluate(() => {
        if (!document.getElementById("ai-cursor")) {
          const cursor = document.createElement("div");
          cursor.id = "ai-cursor";
          document.body.appendChild(cursor);
          const trail = document.createElement("div");
          trail.id = "ai-cursor-trail";
          document.body.appendChild(trail);
          window.cursorPosition ||= { x: 0, y: 0 };
          window.lastPosition ||= { x: 0, y: 0 };
          cursor.style.left = window.cursorPosition.x + "px";
          cursor.style.top = window.cursorPosition.y + "px";
          trail.style.left = window.cursorPosition.x + "px";
          trail.style.top = window.cursorPosition.y + "px";
          const updateCursor = (x, y) => {
            window.cursorPosition = { x, y };
            cursor.style.left = `${x}px`;
            cursor.style.top = `${y}px`;
            requestAnimationFrame(() => {
              trail.style.left = `${x}px`;
              trail.style.top = `${y}px`;
            });
          };
          document.addEventListener("mousemove", (e) => {
            window.lastPosition = window.cursorPosition;
            updateCursor(e.clientX, e.clientY);
          });
        }
      });
    } catch (error) {
      if (error instanceof Error && !error.message.includes("context was destroyed") && !error.message.includes("Target closed")) {
        this.log.error("Cursor initialization failed", getErrorDetails(error));
      }
    }
  }
  async getMetadata() {
    const metadata = {
      window_info: {},
      cursor_info: { position: [0, 0], visible: true }
    };
    try {
      let url;
      let title;
      try {
        url = await this.page.url();
      } catch {
        url = "navigating...";
      }
      try {
        title = await this.page.title();
      } catch {
        title = "loading...";
      }
      metadata.window_info = {
        url,
        title,
        size: this.page.viewportSize() || {
          width: this.width,
          height: this.height
        }
      };
      if (await this.isPageStable()) {
        const position = await getCursorPosition(this.page);
        metadata.cursor_info = {
          position,
          visible: this.cursorVisible
        };
      }
      return metadata;
    } catch (error) {
      this.log.debug("Failed to get metadata:", { error });
      return metadata;
    }
  }
  async isPageStable() {
    try {
      return await this.page.evaluate(
        () => document.readyState === "complete" && !document.querySelector(".loading") && !document.querySelector(".cl-loading")
      ).catch(() => false);
    } catch {
      return false;
    }
  }
  async takeScreenshotWithMetadata() {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const testRun = this.testContext.testRun;
    const repository = TestRunRepository.getRepositoryForTestCase(
      testRun.testCase
    );
    const testRunDirPath = await repository.ensureTestRunDirPath(testRun);
    const screenshotPath = join3(testRunDirPath, `screenshot-${timestamp}.png`);
    const buffer = await this.page.screenshot({
      type: "jpeg",
      quality: 50,
      scale: "device",
      fullPage: false
    });
    await fs7.writeFile(screenshotPath, buffer);
    const filePathWithoutCwd = screenshotPath.replace(process.cwd() + "/", "");
    const browserMetadata = await this.getMetadata();
    this.log.trace("Screenshot saved", {
      filePath: filePathWithoutCwd,
      ...browserMetadata["window_info"]
    });
    return {
      output: "Screenshot taken",
      base64_image: buffer.toString("base64"),
      metadata: browserMetadata
    };
  }
};

// src/browser/manager/index.ts
import { execSync } from "child_process";
import { URL as URL2 } from "url";
import pc4 from "picocolors";
import { chromium } from "playwright";

// ../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/commands.mjs
function npmRun(agent) {
  return (args) => {
    if (args.length > 1) {
      return [agent, "run", args[0], "--", ...args.slice(1)];
    } else {
      return [agent, "run", args[0]];
    }
  };
}
function denoExecute() {
  return (args) => {
    return ["deno", "run", `npm:${args[0]}`, ...args.slice(1)];
  };
}
var npm = {
  "agent": ["npm", 0],
  "run": npmRun("npm"),
  "install": ["npm", "i", 0],
  "frozen": ["npm", "ci", 0],
  "global": ["npm", "i", "-g", 0],
  "add": ["npm", "i", 0],
  "upgrade": ["npm", "update", 0],
  "upgrade-interactive": null,
  "execute": ["npx", 0],
  "execute-local": ["npx", 0],
  "uninstall": ["npm", "uninstall", 0],
  "global_uninstall": ["npm", "uninstall", "-g", 0]
};
var yarn = {
  "agent": ["yarn", 0],
  "run": ["yarn", "run", 0],
  "install": ["yarn", "install", 0],
  "frozen": ["yarn", "install", "--frozen-lockfile", 0],
  "global": ["yarn", "global", "add", 0],
  "add": ["yarn", "add", 0],
  "upgrade": ["yarn", "upgrade", 0],
  "upgrade-interactive": ["yarn", "upgrade-interactive", 0],
  "execute": ["npx", 0],
  "execute-local": ["yarn", "exec", 0],
  "uninstall": ["yarn", "remove", 0],
  "global_uninstall": ["yarn", "global", "remove", 0]
};
var yarnBerry = {
  ...yarn,
  "frozen": ["yarn", "install", "--immutable", 0],
  "upgrade": ["yarn", "up", 0],
  "upgrade-interactive": ["yarn", "up", "-i", 0],
  "execute": ["yarn", "dlx", 0],
  "execute-local": ["yarn", "exec", 0],
  // Yarn 2+ removed 'global', see https://github.com/yarnpkg/berry/issues/821
  "global": ["npm", "i", "-g", 0],
  "global_uninstall": ["npm", "uninstall", "-g", 0]
};
var pnpm = {
  "agent": ["pnpm", 0],
  "run": ["pnpm", "run", 0],
  "install": ["pnpm", "i", 0],
  "frozen": ["pnpm", "i", "--frozen-lockfile", 0],
  "global": ["pnpm", "add", "-g", 0],
  "add": ["pnpm", "add", 0],
  "upgrade": ["pnpm", "update", 0],
  "upgrade-interactive": ["pnpm", "update", "-i", 0],
  "execute": ["pnpm", "dlx", 0],
  "execute-local": ["pnpm", "exec", 0],
  "uninstall": ["pnpm", "remove", 0],
  "global_uninstall": ["pnpm", "remove", "--global", 0]
};
var bun = {
  "agent": ["bun", 0],
  "run": ["bun", "run", 0],
  "install": ["bun", "install", 0],
  "frozen": ["bun", "install", "--frozen-lockfile", 0],
  "global": ["bun", "add", "-g", 0],
  "add": ["bun", "add", 0],
  "upgrade": ["bun", "update", 0],
  "upgrade-interactive": ["bun", "update", 0],
  "execute": ["bun", "x", 0],
  "execute-local": ["bun", "x", 0],
  "uninstall": ["bun", "remove", 0],
  "global_uninstall": ["bun", "remove", "-g", 0]
};
var deno = {
  "agent": ["deno", 0],
  "run": ["deno", "task", 0],
  "install": ["deno", "install", 0],
  "frozen": ["deno", "install", "--frozen", 0],
  "global": ["deno", "install", "-g", 0],
  "add": ["deno", "add", 0],
  "upgrade": ["deno", "outdated", "--update", 0],
  "upgrade-interactive": ["deno", "outdated", "--update", 0],
  "execute": denoExecute(),
  "execute-local": ["deno", "task", "--eval", 0],
  "uninstall": ["deno", "remove", 0],
  "global_uninstall": ["deno", "uninstall", "-g", 0]
};
var COMMANDS = {
  "npm": npm,
  "yarn": yarn,
  "yarn@berry": yarnBerry,
  "pnpm": pnpm,
  // pnpm v6.x or below
  "pnpm@6": {
    ...pnpm,
    run: npmRun("pnpm")
  },
  "bun": bun,
  "deno": deno
};
function resolveCommand(agent, command, args) {
  const value = COMMANDS[agent][command];
  return constructCommand(value, args);
}
function constructCommand(value, args) {
  if (value == null)
    return null;
  const list = typeof value === "function" ? value(args) : value.flatMap((v) => {
    if (typeof v === "number")
      return args;
    return [v];
  });
  return {
    command: list[0],
    args: list.slice(1)
  };
}

// ../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/constants.mjs
var AGENTS = [
  "npm",
  "yarn",
  "yarn@berry",
  "pnpm",
  "pnpm@6",
  "bun",
  "deno"
];
var LOCKS = {
  "bun.lock": "bun",
  "bun.lockb": "bun",
  "deno.lock": "deno",
  "pnpm-lock.yaml": "pnpm",
  "yarn.lock": "yarn",
  "package-lock.json": "npm",
  "npm-shrinkwrap.json": "npm"
};

// ../../node_modules/.pnpm/package-manager-detector@0.2.9/node_modules/package-manager-detector/dist/detect.mjs
import fs8 from "node:fs";
import fsPromises from "node:fs/promises";
import path7 from "node:path";
import process2 from "node:process";
async function detect(options = {}) {
  const { cwd, onUnknown } = options;
  for (const directory of lookup(cwd)) {
    for (const lock of Object.keys(LOCKS)) {
      if (await fileExists(path7.join(directory, lock))) {
        const name = LOCKS[lock];
        const result2 = await parsePackageJson(path7.join(directory, "package.json"), onUnknown);
        if (result2)
          return result2;
        else
          return { name, agent: name };
      }
    }
    const result = await parsePackageJson(path7.join(directory, "package.json"), onUnknown);
    if (result)
      return result;
  }
  return null;
}
function* lookup(cwd = process2.cwd()) {
  let directory = path7.resolve(cwd);
  const { root } = path7.parse(directory);
  while (directory && directory !== root) {
    yield directory;
    directory = path7.dirname(directory);
  }
}
async function parsePackageJson(filepath, onUnknown) {
  return !filepath || !await fileExists(filepath) ? null : handlePackageManager(filepath, onUnknown);
}
function handlePackageManager(filepath, onUnknown) {
  try {
    const pkg = JSON.parse(fs8.readFileSync(filepath, "utf8"));
    let agent;
    if (typeof pkg.packageManager === "string") {
      const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
      let version = ver;
      if (name === "yarn" && Number.parseInt(ver) > 1) {
        agent = "yarn@berry";
        version = "berry";
        return { name, agent, version };
      } else if (name === "pnpm" && Number.parseInt(ver) < 7) {
        agent = "pnpm@6";
        return { name, agent, version };
      } else if (AGENTS.includes(name)) {
        agent = name;
        return { name, agent, version };
      } else {
        return onUnknown?.(pkg.packageManager) ?? null;
      }
    }
  } catch {
  }
  return null;
}
async function fileExists(filePath) {
  try {
    const stats = await fsPromises.stat(filePath);
    if (stats.isFile()) {
      return true;
    }
  } catch {
  }
  return false;
}

// src/utils/platform.ts
var getInstallationCommand = async () => {
  const packageManager = await detect();
  if (!packageManager) {
    throw new ShortestError("No package manager detected");
  }
  const command = resolveCommand(packageManager.agent, "execute", [
    "playwright",
    "install",
    "chromium"
  ]);
  if (!command) {
    throw new ShortestError(
      "Failed to resolve Playwright browser installation command"
    );
  }
  return `${command.command} ${command.args.join(" ")}`;
};

// src/browser/manager/index.ts
var BrowserManager = class {
  browser = null;
  context = null;
  config;
  log;
  constructor(config) {
    this.config = config;
    this.log = getLogger();
  }
  async launch() {
    try {
      this.browser = await chromium.launch({
        headless: this.config.headless ?? false
      });
    } catch (error) {
      if (error instanceof Error && error.message.includes("Executable doesn't exist")) {
        this.log.info("Installing Playwright browser...");
        const installationCommand = await getInstallationCommand();
        execSync(installationCommand, { stdio: "inherit" });
        this.log.info(pc4.green("\u2713"), "Playwright browser installed");
        this.browser = await chromium.launch({
          headless: this.config.headless ?? false
        });
      } else {
        throw error;
      }
    }
    const contextOptions = {
      viewport: { width: 1920, height: 1080 },
      baseURL: this.config.baseUrl,
      ...this.config.browser?.contextOptions
    };
    this.log.trace("Initializing browser context", { options: contextOptions });
    this.context = await this.browser.newContext(contextOptions);
    const page = await this.context.newPage();
    await page.goto(this.normalizeUrl(this.config.baseUrl));
    await page.waitForLoadState("networkidle");
    return this.context;
  }
  async clearContext() {
    if (!this.context) {
      throw new ShortestError("No context available");
    }
    await Promise.all([
      this.context.clearCookies(),
      // Clear storage
      this.context.pages().map(
        (page) => page.evaluate(() => {
          localStorage.clear();
          sessionStorage.clear();
          indexedDB.deleteDatabase("shortest");
        })
      ),
      // Clear permissions
      this.context.clearPermissions()
    ]);
    await Promise.all(
      this.context.pages().map((page) => page.goto("about:blank"))
    );
    const pages = this.context.pages();
    if (pages.length > 1) {
      await Promise.all(pages.slice(1).map((page) => page.close()));
    }
    const baseUrl = this.config.baseUrl;
    await pages[0].goto(baseUrl);
    await pages[0].waitForLoadState("networkidle");
    return this.context;
  }
  async recreateContext() {
    return this.clearContext();
  }
  async close() {
    if (this.context) {
      await this.context.close();
      this.context = null;
    }
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }
  getContext() {
    return this.context;
  }
  getBrowser() {
    return this.browser;
  }
  normalizeUrl(url) {
    try {
      const parsedUrl = new URL2(url);
      return parsedUrl.toString();
    } catch {
      return url;
    }
  }
};

// src/core/runner/test-file-parser.ts
import { readFileSync } from "fs";
import { createRequire as createRequire2 } from "module";
import * as parser2 from "@babel/parser";
import * as babelTypes from "@babel/types";
var require3 = createRequire2(import.meta.url);
var traverse2 = require3("@babel/traverse").default;
var EXPRESSION_PLACEHOLDER = "${...}";
var TestLocationSchema = z.object({
  testName: z.string(),
  startLine: z.number().int().positive(),
  endLine: z.number().int().positive()
});
var TestLocationsSchema = z.array(TestLocationSchema);
var parseShortestTestFile = (filePath) => {
  const log = getLogger();
  try {
    log.setGroup("File Parser");
    const TemplateElementSchema = z.object({
      value: z.object({
        cooked: z.string().optional(),
        raw: z.string().optional()
      })
    });
    const StringLiteralSchema = z.object({
      type: z.literal("StringLiteral"),
      value: z.string()
    });
    const TemplateLiteralSchema = z.object({
      type: z.literal("TemplateLiteral"),
      quasis: z.array(TemplateElementSchema)
    });
    const fileContent = readFileSync(filePath, "utf8");
    const ast = parser2.parse(fileContent, {
      sourceType: "module",
      plugins: [
        "typescript",
        "objectRestSpread",
        "optionalChaining",
        "nullishCoalescingOperator"
      ]
    });
    const testLocations = [];
    const testCallsByLine = /* @__PURE__ */ new Map();
    traverse2(ast, {
      CallExpression(path11) {
        const node = path11.node;
        if (!node.type || node.type !== "CallExpression" || !node.callee || node.callee.type !== "Identifier" || node.callee.name !== SHORTEST_NAME) {
          return;
        }
        const args = node.arguments || [];
        if (args.length === 0)
          return;
        const firstArg = args[0];
        let testName = "";
        if (babelTypes.isStringLiteral(firstArg)) {
          const parsed = StringLiteralSchema.parse(firstArg);
          testName = parsed.value;
        } else if (babelTypes.isTemplateLiteral(firstArg)) {
          const parsed = TemplateLiteralSchema.parse(firstArg);
          testName = parsed.quasis.map(
            (quasi, i, arr) => {
              const str = quasi.value.cooked || quasi.value.raw || "";
              return i < arr.length - 1 ? str + EXPRESSION_PLACEHOLDER : str;
            }
          ).join("").replace(/\s+/g, " ").trim();
        } else {
          return;
        }
        const startLine = node.loc?.start?.line || 0;
        testCallsByLine.set(startLine, {
          name: testName,
          node: path11
        });
      }
    });
    const sortedStartLines = Array.from(testCallsByLine.keys()).sort(
      (a, b) => a - b
    );
    for (let i = 0; i < sortedStartLines.length; i++) {
      const currentLine = sortedStartLines[i];
      const nextLine = sortedStartLines[i + 1] || Number.MAX_SAFE_INTEGER;
      const { name, node } = testCallsByLine.get(currentLine);
      let path11 = node;
      let endLine = path11.node.loc?.end?.line || 0;
      let currentPath = path11;
      while (currentPath.parentPath && (currentPath.parentPath.node.loc?.end?.line ?? 0) < nextLine) {
        const parentType = currentPath.parentPath.node.type;
        if (parentType === "ExpressionStatement") {
          endLine = currentPath.parentPath.node.loc?.end?.line || endLine;
          break;
        }
        if (parentType === "CallExpression" || parentType === "MemberExpression") {
          currentPath = currentPath.parentPath;
          endLine = Math.max(endLine, currentPath.node.loc?.end?.line || 0);
        } else {
          endLine = Math.max(
            endLine,
            currentPath.parentPath.node.loc?.end?.line || endLine
          );
          break;
        }
      }
      endLine = Math.min(endLine, nextLine - 1);
      const testLocation = TestLocationSchema.parse({
        testName: name,
        startLine: currentLine,
        endLine
      });
      testLocations.push(testLocation);
    }
    log.trace("Test locations", { filePath, testLocations });
    return TestLocationsSchema.parse(testLocations);
  } finally {
    log.resetGroup();
  }
};

// src/core/runner/test-reporter.ts
import pc5 from "picocolors";
var TestReporter = class {
  startTime = Date.now();
  reporterLog;
  log;
  // token pricing (Claude 3.5 Sonnet)
  COST_PER_1K_PROMPT_TOKENS = 3e-3;
  COST_PER_1K_COMPLETION_TOKENS = 0.015;
  filesCount = 0;
  testsCount = 0;
  passedTestsCount = 0;
  failedTestsCount = 0;
  totalPromptTokens = 0;
  totalCompletionTokens = 0;
  aiCost = 0;
  constructor() {
    this.reporterLog = getReporterLog();
    this.log = getLogger();
  }
  onRunStart(filesCount) {
    this.filesCount = filesCount;
    this.reporterLog.info(`Found ${filesCount} test file(s)`);
  }
  onFileStart(filePath, testsCount) {
    this.log.setGroup(filePath);
    this.reporterLog.info(
      pc5.cyan("\u276F"),
      pc5.blue(pc5.bold(filePath)),
      pc5.dim(`(${testsCount})`)
    );
    this.reporterLog.setGroup(filePath);
    this.testsCount += testsCount;
  }
  onTestStart(test2) {
    this.log.trace("onTestStart called");
    this.log.setGroup(test2.name);
    this.reporterLog.info(this.getStatusIcon("running"), test2.name);
    this.reporterLog.setGroup(test2.name);
  }
  onTestEnd(testRun) {
    this.log.trace("onTestEnd called");
    switch (testRun.status) {
      case "passed":
        this.passedTestsCount++;
        break;
      case "failed":
        this.failedTestsCount++;
        break;
    }
    let testAICost = 0;
    if (testRun.tokenUsage) {
      this.totalPromptTokens += testRun.tokenUsage.promptTokens;
      this.totalCompletionTokens += testRun.tokenUsage.completionTokens;
      testAICost = this.calculateCost(
        testRun.tokenUsage.promptTokens,
        testRun.tokenUsage.completionTokens
      );
      this.aiCost += testAICost;
    }
    const symbol = testRun.status === "passed" ? "\u2713" : "\u2717";
    const color = testRun.status === "passed" ? pc5.green : pc5.red;
    this.reporterLog.info(`${color(`${symbol} ${testRun.status}`)}`);
    if (testRun.tokenUsage.totalTokens > 0) {
      const cost = this.calculateCost(
        testRun.tokenUsage.promptTokens,
        testRun.tokenUsage.completionTokens
      );
      this.reporterLog.info(
        pc5.dim("\u21B3"),
        pc5.dim(`${testRun.tokenUsage.totalTokens.toLocaleString()} tokens`),
        pc5.dim(`(\u2248 $${cost.toFixed(2)})`)
      );
    }
    if (testRun.status === "failed") {
      this.error("Reason", testRun.reason);
    }
    this.reporterLog.resetGroup();
    this.log.resetGroup();
  }
  onFileEnd(fileResult) {
    if (fileResult.status === "failed") {
      this.log.error("Error processing file", { ...fileResult });
      this.error("Error processing file", fileResult.reason);
    }
    this.reporterLog.resetGroup();
    this.log.resetGroup();
  }
  onRunEnd() {
    this.summary();
  }
  allTestsPassed() {
    return this.testsCount === this.passedTestsCount;
  }
  error(context, message) {
    this.reporterLog.error(pc5.red(`${context}: ${message}`));
  }
  reportAssertion(step, status, error) {
    if (status === "passed") {
      this.reporterLog.error(pc5.green(`\u2713 ${step}`));
    } else {
      this.reporterLog.error(pc5.red(`\u2717 ${step}`));
      if (error) {
        this.reporterLog.error(pc5.dim(error.message));
      }
    }
  }
  calculateCost(promptTokens, completionTokens) {
    const promptTokensCost = promptTokens / 1e3 * this.COST_PER_1K_PROMPT_TOKENS;
    const completionTokensCost = completionTokens / 1e3 * this.COST_PER_1K_COMPLETION_TOKENS;
    return Math.round((promptTokensCost + completionTokensCost) * 1e3) / 1e3;
  }
  getStatusIcon(status) {
    switch (status) {
      case "pending":
        return pc5.yellow("\u25CB");
      case "running":
        return pc5.cyan("\u25CF");
      case "passed":
        return pc5.green("\u2713");
      case "failed":
        return pc5.red("\u2717");
    }
  }
  summary() {
    const duration = ((Date.now() - this.startTime) / 1e3).toFixed(2);
    const totalTokens = this.totalPromptTokens + this.totalCompletionTokens;
    const aiCost = this.calculateCost(
      this.totalPromptTokens,
      this.totalCompletionTokens
    );
    this.reporterLog.setGroup("Summary");
    this.reporterLog.info(pc5.dim("\u23AF".repeat(50)), "\n");
    const LABEL_WIDTH = 15;
    this.reporterLog.info(
      pc5.bold(" Tests".padEnd(LABEL_WIDTH)),
      this.failedTestsCount ? `${pc5.red(`${this.failedTestsCount} failed`)} | ${pc5.green(`${this.passedTestsCount} passed`)}` : pc5.green(`${this.passedTestsCount} passed`),
      pc5.dim(`(${this.testsCount})`)
    );
    this.reporterLog.info(
      pc5.bold(" Duration".padEnd(LABEL_WIDTH)),
      pc5.dim(`${duration}s`)
    );
    this.reporterLog.info(
      pc5.bold(" Started at".padEnd(LABEL_WIDTH)),
      pc5.dim(new Date(this.startTime).toLocaleTimeString())
    );
    this.reporterLog.info(
      pc5.bold(" Tokens".padEnd(LABEL_WIDTH)),
      pc5.dim(
        `${totalTokens.toLocaleString()} tokens (\u2248 $${aiCost.toFixed(2)})`
      )
    );
    this.reporterLog.info("\n", pc5.dim("\u23AF".repeat(50)));
    this.reporterLog.resetGroup();
  }
};
var reporterLogInstance = null;
var getReporterLog = () => {
  if (reporterLogInstance) {
    return reporterLogInstance;
  }
  reporterLogInstance = new Log({
    level: "info",
    format: "reporter"
  });
  return reporterLogInstance;
};

// src/core/runner/index.ts
var testStatusSchema = z.enum(["pending", "running", "passed", "failed"]);
var FileResultSchema = z.object({
  filePath: z.string(),
  status: testStatusSchema,
  reason: z.string()
});
var TestRunner = class {
  config;
  cwd;
  compiler;
  browserManager;
  reporter;
  testContext = null;
  testFileContext = null;
  log;
  constructor(cwd, config) {
    this.config = config;
    this.cwd = cwd;
    this.compiler = new TestCompiler();
    this.reporter = new TestReporter();
    this.log = getLogger();
  }
  async initialize() {
    this.browserManager = new BrowserManager(this.config);
  }
  async execute(testPattern, lineNumber) {
    this.log.trace("Finding test files", { testPattern });
    const files = await glob(testPattern, {
      cwd: this.cwd,
      absolute: true
    });
    this.log.trace("Found test files", { files });
    if (files.length === 0) {
      this.reporter.error(
        "Test Discovery",
        `No test files found matching the test pattern ${testPattern}`
      );
      this.log.error("No test files found matching", {
        pattern: testPattern
      });
      return false;
    }
    this.reporter.onRunStart(files.length);
    for (const file of files) {
      await this.executeTestFile(file, lineNumber);
    }
    this.reporter.onRunEnd();
    return this.reporter.allTestsPassed();
  }
  async executeTest(testRun, context, skipCache = false) {
    const testCase = testRun.testCase;
    this.log.trace("Executing test", {
      name: testCase.name,
      filePath: testCase.filePath,
      payload: testCase.payload,
      skipCache
    });
    if (testCase.directExecution) {
      try {
        const testContext2 = await this.createTestContext(testRun);
        await testCase.fn?.(testContext2);
        testRun.markPassed({ reason: "Direct execution successful" });
        return testRun;
      } catch (error) {
        testRun.markFailed({
          reason: error instanceof Error ? error.message : "Direct execution failed"
        });
        return testRun;
      }
    }
    const testContext = await this.createTestContext(testRun);
    const browserTool = new BrowserTool(testContext.page, this.browserManager, {
      width: 1920,
      height: 1080,
      testContext: {
        ...testContext,
        testRun,
        currentStepIndex: 0
      }
    });
    const initialState = await browserTool.execute({
      action: "screenshot"
    });
    if (this.config.caching.enabled && !skipCache) {
      try {
        await this.runCachedTest(testRun, browserTool);
        if (testCase.afterFn) {
          try {
            await testCase.afterFn(testContext);
          } catch (error) {
            testRun.markFailed({
              reason: testRun.status === "failed" ? `AI: ${testRun.reason}, After: ${error instanceof Error ? error.message : String(error)}` : error instanceof Error ? error.message : String(error)
            });
          }
        }
        return testRun;
      } catch (error) {
        if (!(error instanceof CacheError))
          throw error;
        this.log.error(
          "Cache execution interrupted, falling back to normal execution",
          getErrorDetails(error)
        );
        const page = browserTool.getPage();
        await page.goto(initialState.metadata?.window_info?.url);
        return await this.executeTest(testRun, context, true);
      }
    } else {
      this.log.trace("Skipping cache", {
        cachingEnabled: this.config.caching.enabled,
        skipCache
      });
    }
    if (testCase.beforeFn) {
      try {
        await testCase.beforeFn(testContext);
      } catch (error) {
        testRun.markFailed({
          reason: error instanceof Error ? error.message : String(error)
        });
        return testRun;
      }
    }
    let aiResponse;
    try {
      this.log.setGroup("\u{1F916}");
      const prompt = [
        `Test: "${testCase.name}"`,
        testCase.payload ? `Context: ${JSON.stringify(testCase.payload)}` : "",
        `Callback function: ${testCase.fn ? " [HAS_CALLBACK]" : " [NO_CALLBACK]"}`,
        // Add expectations if they exist
        ...testCase.expectations?.length ? [
          "\nExpect:",
          ...testCase.expectations.map(
            (exp, i) => `${i + 1}. ${exp.description}${exp.fn ? " [HAS_CALLBACK]" : "[NO_CALLBACK]"}`
          )
        ] : ["\nExpect:", `1. "${testCase.name}" expected to be successful`],
        "\nCurrent Page State:",
        `URL: ${initialState.metadata?.window_info?.url || "unknown"}`,
        `Title: ${initialState.metadata?.window_info?.title || "unknown"}`
      ].filter(Boolean).join("\n");
      const aiClient = new AIClient({ browserTool, testRun });
      aiResponse = await aiClient.runAction(prompt);
    } finally {
      this.log.resetGroup();
    }
    if (testCase.afterFn) {
      try {
        await testCase.afterFn(testContext);
      } catch (error) {
        testRun.markFailed({
          reason: aiResponse.response.status === "failed" ? `AI: ${aiResponse.response.reason}, After: ${error instanceof Error ? error.message : String(error)}` : error instanceof Error ? error.message : String(error),
          tokenUsage: aiResponse.metadata.usage
        });
        return testRun;
      }
    }
    switch (aiResponse.response.status) {
      case "passed":
        testRun.markPassed({
          reason: aiResponse.response.reason,
          tokenUsage: aiResponse.metadata.usage
        });
        break;
      case "failed":
        testRun.markFailed({
          reason: aiResponse.response.reason,
          tokenUsage: aiResponse.metadata.usage
        });
        break;
      default:
        throw new ShortestError(
          `Unexpected AI response status: ${aiResponse.response.status}`
        );
    }
    return testRun;
  }
  async runCachedTest(testRun, browserTool) {
    try {
      this.log.setGroup("\u{1F4BE}");
      this.log.trace("Attempting to execute test from cache", {
        identifier: testRun.testCase.identifier
      });
      const latestRun = await TestRunRepository.getRepositoryForTestCase(
        testRun.testCase
      ).getLatestPassedRun();
      if (!latestRun) {
        throw new CacheError(
          "not-found",
          "No successful cached test run found"
        );
      }
      const filteredSteps = latestRun.steps?.filter(
        (step) => step.action?.input.action !== "screenshot" /* SCREENSHOT */.toString()
      );
      this.log.trace("Using cached test run", {
        runId: latestRun.runId,
        stepCount: latestRun.steps.length,
        filteredStepCount: filteredSteps.length
      });
      if (!filteredSteps || filteredSteps.length === 0) {
        throw new CacheError("invalid", "No eligible steps in cache");
      }
      for (const step of filteredSteps) {
        await new Promise((resolve2) => setTimeout(resolve2, 1e3));
        if (step.action?.input.action === "mouse_move" /* MOUSE_MOVE */ && step.action.input.coordinate) {
          const [x, y] = step.action.input.coordinate;
          const componentStr = await browserTool.getNormalizedComponentStringByCoords(x, y);
          if (componentStr !== step.extras.componentStr) {
            this.log.trace("UI element mismatch with cached UI element", {
              componentStr,
              stepComponentStr: step.extras.componentStr
            });
            throw new CacheError("invalid", "UI element mismatch");
          }
        }
        if (step.action?.input) {
          try {
            await browserTool.execute(step.action.input);
          } catch (error) {
            this.log.error("Failed to execute cached step", {
              input: step.action.input,
              ...getErrorDetails(error)
            });
            throw new CacheError("invalid", "Error executing cached step");
          }
        }
      }
      this.log.debug("Successfully executed all cached steps");
      testRun.markPassedFromCache({
        reason: "All actions successfully replayed from cache"
      });
      return testRun;
    } finally {
      this.log.resetGroup();
    }
  }
  async executeTestFile(filePath, lineNumber) {
    const registry = global.__shortest__.registry;
    try {
      this.log.trace("Executing test file", { filePath, lineNumber });
      registry.tests.clear();
      registry.currentFileTests = [];
      const filePathWithoutCwd = filePath.replace(this.cwd + "/", "");
      registry.currentFilePath = filePathWithoutCwd;
      const compiledPath = await this.compiler.compileFile(filePath);
      this.log.trace("Importing compiled file", { compiledPath });
      await import(pathToFileURL(compiledPath).href);
      let testsToRun = registry.currentFileTests;
      if (lineNumber) {
        testsToRun = await this.filterTestsByLineNumber(
          registry.currentFileTests,
          filePath,
          lineNumber
        );
        if (testsToRun.length === 0) {
          this.reporter.error(
            "Test Discovery",
            `No test found at line ${lineNumber} in ${filePathWithoutCwd}`
          );
          throw new ShortestError(
            `No test found at line ${lineNumber} in ${filePathWithoutCwd}`
          );
        }
      }
      let context;
      try {
        this.log.trace("Launching browser");
        context = await this.browserManager.launch();
      } catch (error) {
        this.log.error("Browser launching failed", getErrorDetails(error));
        throw asShortestError(error);
      }
      this.log.trace("Creating test context");
      const testContext = await this.createFileTestContext(context);
      try {
        for (const hook of registry.beforeAllFns) {
          await hook(testContext);
        }
        this.reporter.onFileStart(filePathWithoutCwd, testsToRun.length);
        this.log.info(`Running ${testsToRun.length} test(s)`);
        for (const testCase of testsToRun) {
          for (const hook of registry.beforeEachFns) {
            await hook(testContext);
          }
          this.reporter.onTestStart(testCase);
          const testRun = TestRun.create(testCase);
          try {
            testRun.markRunning();
            await this.executeTest(testRun, context);
          } catch (error) {
            this.log.error(
              "Handling error for executeTest",
              getErrorDetails(error)
            );
            throw error;
          }
          this.reporter.onTestEnd(testRun);
          for (const hook of registry.afterEachFns) {
            await hook(testContext);
          }
          await TestRunRepository.getRepositoryForTestCase(testCase).saveRun(
            testRun
          );
          try {
            await TestRunRepository.getRepositoryForTestCase(
              testCase
            ).applyRetentionPolicy();
          } catch (error) {
            this.log.error(
              "Failed to apply retention policy",
              getErrorDetails(error)
            );
          }
        }
        for (const hook of registry.afterAllFns) {
          await hook(testContext);
        }
      } finally {
        await this.browserManager.close();
        this.testContext = null;
        registry.beforeAllFns = [];
        registry.afterAllFns = [];
        registry.beforeEachFns = [];
        registry.afterEachFns = [];
        const fileResult = {
          filePath,
          status: "passed",
          reason: ""
        };
        this.reporter.onFileEnd(fileResult);
      }
    } catch (error) {
      this.log.trace("Handling error for executeTestFile");
      if (!(error instanceof ShortestError))
        throw error;
      const fileResult = {
        filePath,
        status: "failed",
        reason: error.message
      };
      this.reporter.onFileEnd(fileResult);
    } finally {
      registry.currentFilePath = "";
      this.testContext = null;
    }
  }
  async filterTestsByLineNumber(tests, file, lineNumber) {
    const testLocations = parseShortestTestFile(file);
    const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const filteredTests = tests.filter((test2) => {
      const testNameNormalized = test2.name.trim();
      let testLocation = testLocations.find(
        (location) => location.testName === testNameNormalized
      );
      if (!testLocation) {
        testLocation = testLocations.find((location) => {
          const TEMP_TOKEN = "##PLACEHOLDER##";
          let pattern = location.testName.replace(
            new RegExp(escapeRegex(EXPRESSION_PLACEHOLDER), "g"),
            TEMP_TOKEN
          );
          pattern = escapeRegex(pattern);
          pattern = pattern.replace(new RegExp(TEMP_TOKEN, "g"), ".*");
          const regex = new RegExp(`^${pattern}$`);
          return regex.test(testNameNormalized);
        });
      }
      if (!testLocation) {
        return false;
      }
      const isInRange = lineNumber >= testLocation.startLine && lineNumber <= testLocation.endLine;
      return isInRange;
    });
    return filteredTests;
  }
  async createFileTestContext(context) {
    if (!this.testFileContext) {
      const playwrightObj = {
        ...playwright,
        request: {
          ...request,
          newContext: async (options) => {
            const requestContext = await request.newContext({
              baseURL: this.config.baseUrl,
              ...options
            });
            return requestContext;
          }
        }
      };
      this.testFileContext = {
        page: context.pages()[0],
        browser: this.browserManager.getBrowser(),
        playwright: playwrightObj
      };
    }
    return this.testFileContext;
  }
  async createTestContext(testRun) {
    if (this.testContext)
      return this.testContext;
    return { ...assertDefined(this.testFileContext), testRun };
  }
};

// src/cli/commands/shortest.ts
var SHORTEST_NAME = "shortest";
var { version: currentVersion } = require_package();
var shortestCommand = new Command4(SHORTEST_NAME).description(`${pc6.cyan("AI-powered end-to-end testing framework")}`).version(currentVersion).configureHelp({
  styleTitle: (title) => pc6.bold(title)
}).configureOutput({
  outputError: (str, write) => write(pc6.red(str))
}).showHelpAfterError("(add --help for additional information)").addHelpText(
  "after",
  `
${pc6.bold("Environment setup:")}
  Required in ${ENV_LOCAL_FILENAME}:
    AI authentication
      SHORTEST_ANTHROPIC_API_KEY                  Anthropic API key for AI test execution
      ANTHROPIC_API_KEY                           Alternative Anthropic API key (only one is required)

${pc6.bold("Documentation:")}
  ${pc6.cyan("https://github.com/antiwork/shortest")}
`
);
shortestCommand.addOption(
  new Option4("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).option("--headless", "Run tests in headless browser mode").option(
  "--target <url>",
  "Set target URL for tests",
  cliOptionsSchema.shape.baseUrl._def.defaultValue()
).option("--no-cache", "Disable test action caching").argument(
  "[test-pattern]",
  "Test pattern to run",
  cliOptionsSchema.shape.testPattern._def.defaultValue()
).action(async (testPattern, _options, command) => {
  await executeCommand(
    command.name(),
    command.optsWithGlobals(),
    async () => await executeTestRunnerCommand(testPattern, command.optsWithGlobals())
  );
});
var executeTestRunnerCommand = async (testPattern, options) => {
  const log = getLogger();
  log.trace("Starting Shortest CLI", { args: process.argv });
  log.trace("Log config", { ...log.config });
  let lineNumber;
  if (testPattern?.includes(":")) {
    const [file, line] = testPattern.split(":");
    testPattern = file;
    lineNumber = parseInt(line, 10);
  }
  const cliOptions = {
    headless: options.headless,
    baseUrl: options.target,
    testPattern,
    noCache: !options.cache
  };
  log.trace("Initializing config with CLI options", { cliOptions });
  await initializeConfig({ cliOptions });
  const config = getConfig();
  await purgeLegacyCache();
  await purgeLegacyScreenshots();
  try {
    log.trace("Initializing TestRunner");
    const runner = new TestRunner(process.cwd(), config);
    await runner.initialize();
    const success = await runner.execute(config.testPattern, lineNumber);
    process.exitCode = success ? 0 : 1;
  } catch (error) {
    log.trace("Handling error for TestRunner");
    if (!(error instanceof ShortestError))
      throw error;
    log.error(error.message, getErrorDetails(error));
    process.exitCode = 1;
  } finally {
    await cleanUpCache();
  }
};

// src/core/test-generator/utils/format-code.ts
import fs9 from "fs/promises";
import { createRequire as createRequire3 } from "module";
import path8 from "path";
var require4 = createRequire3(import.meta.url);
var formatCode = async (code, rootDir) => {
  const log = getLogger();
  log.trace("Formatting code using Prettier", { rootDir });
  let formattedCode = code;
  try {
    const prettierPath = require4.resolve("prettier", {
      paths: [rootDir]
    });
    let prettier = await import(prettierPath);
    if (prettier.default) {
      prettier = prettier.default;
    }
    let prettierConfig = await prettier.resolveConfig(rootDir);
    if (!prettierConfig) {
      log.trace(
        "No Prettier config found via resolveConfig, checking for config files"
      );
      const prettierConfigMjsPath = path8.join(rootDir, "prettier.config.mjs");
      try {
        if (await fs9.stat(prettierConfigMjsPath).then(() => true).catch(() => false)) {
          log.trace("Found prettier.config.mjs, loading config");
          const configModule = await import(`file://${prettierConfigMjsPath}`);
          prettierConfig = configModule.default;
          log.trace("Loaded prettier.config.mjs", { prettierConfig });
        }
      } catch (configError) {
        log.trace(
          "Error loading prettier.config.mjs",
          getErrorDetails(configError)
        );
      }
      if (!prettierConfig) {
        try {
          const prettierrcPath = path8.join(rootDir, ".prettierrc");
          if (await fs9.stat(prettierrcPath).then(() => true).catch(() => false)) {
            log.trace("Loading from .prettierrc");
            const configContent = await fs9.readFile(prettierrcPath, "utf8");
            prettierConfig = JSON.parse(configContent);
            log.trace("Loaded .prettierrc directly", { prettierConfig });
          }
        } catch (prettierrcError) {
          log.trace(
            "Error loading .prettierrc",
            getErrorDetails(prettierrcError)
          );
        }
      }
    }
    if (prettierConfig) {
      formattedCode = await prettier.format(formattedCode, {
        ...prettierConfig,
        parser: "typescript"
      });
    }
  } catch (error) {
    log.error(
      "Could not use Prettier to format code, skipping formatting",
      getErrorDetails(error)
    );
  }
  return formattedCode;
};

// src/core/test-generator/utils/lint-code.ts
import { createRequire as createRequire4 } from "module";
var require5 = createRequire4(import.meta.url);
var lintCode = async (code, rootDir) => {
  const log = getLogger();
  log.trace("Linting code using ESLint");
  let lintedCode = code;
  try {
    log.trace("Loading ESLint", { rootDir });
    const eslintPath = require5.resolve("eslint", {
      paths: [rootDir]
    });
    log.trace("ESLint path", { eslintPath });
    const { ESLint } = await import(eslintPath);
    const customConfig = {
      rules: {
        "padding-line-between-statements": [
          "error",
          { blankLine: "always", prev: "expression", next: "expression" },
          { blankLine: "always", prev: "import", next: "*" }
        ]
      }
    };
    const eslint = new ESLint({
      fix: true,
      cwd: rootDir,
      overrideConfig: customConfig
    });
    const results = await eslint.lintText(code);
    if (results[0]?.output) {
      lintedCode = results[0].output;
      log.trace("ESLint applied fixes to the code");
    } else {
      log.trace("ESLint found no issues to fix");
    }
    if (results[0]?.messages?.length > 0) {
      const issueCount = results[0].messages.length;
      log.trace(
        `ESLint found ${issueCount} issues that couldn't be automatically fixed`
      );
    }
  } catch (error) {
    log.error(
      "Could not use ESLint to lint code, skipping linting",
      getErrorDetails(error)
    );
  }
  return lintedCode;
};

// src/core/test-planner/index.ts
import fs10 from "fs/promises";
import path9 from "path";
import { generateText as generateText2 } from "ai";

// src/core/test-planner/system-prompt.ts
var SYSTEM_PROMPT2 = `You are an expert test architect program specializing in writing end-to-end testing plans. You can only respond in JSON format. Your role is to:

1. Analyze the provided application structure
2. Create a testing plan that covers the main functional flows, up to 10 plans


**Test plan action items**
1. Keep track if the plan requires authentication
2. Generate the steps to reproduce the test plan, not more than 5 steps. If more than 5 steps are needed, split into multiple test plans.
3. Each step should be a natural language description of the action to be taken, not more than 10 words.
4. Once all the steps are generated, review if any of the steps requires authentication. If so, include the step to log out as the last step of the plan.

**Format output**
Return a JSON object with the following fields:
- testPlans: An array of test plans
Each test plan must have the following fields:
- steps: An array of strings representing the step (simple sentence, not more than 10 words)
- options: An object with the following fields:
  - options.requiresAuth: Optional. A boolean indicating if the step plan requires authentication (any step in the plan requires authentication).

**IMPORTANT**

The final response MUST return only a JSON output that can be parsed by the JSON parser. DO NOT return as markdown, just return the JSON object.

**Other rules**
- Do not use component names to navigate to a certain page, as those are not visible to the user.
- Do not add instructions to navigate to a certain URL. Instead, If the user need to navigate to a certain page, use UI element names (or generic names) to navigate to it.

If a given test plan requires authentication, include the step to log in.

For context, the test plans will be converted into tests using a testing framework called Shortest, based on Playwright. The tests will be executed using a computer use agent that will navigate the application and interact with it.

The application is using Next.js 15 framework. Leverage this knowledge to write the test plans.`;

// src/core/test-planner/index.ts
var TestPlanSchema = z.object({
  testPlans: z.array(
    z.object({
      steps: z.array(z.string()),
      options: z.object({
        requiresAuth: z.boolean().optional()
      })
    })
  )
});
var TestPlanner = class _TestPlanner {
  static TEST_PLAN_FILE_NAME = "test-plan.json";
  frameworkInfo;
  log = getLogger();
  TEST_PLAN_VERSION = 1;
  cacheFrameworkDir;
  constructor(frameworkInfo) {
    this.frameworkInfo = frameworkInfo;
    this.cacheFrameworkDir = path9.join(
      DOT_SHORTEST_DIR_PATH,
      this.frameworkInfo.id
    );
  }
  async execute(options = {}) {
    this.log.trace("Executing test plan...", {
      framework: this.frameworkInfo
    });
    if (!options.force) {
      const existingTestPlanInfo = await this.getExistingTestPlans();
      if (existingTestPlanInfo) {
        this.log.trace("Using existing test plan from cache");
        return existingTestPlanInfo.data.testPlans;
      }
    }
    const testPlans = await this.createTestPlans();
    await this.saveTestPlansToFile(testPlans);
    return testPlans;
  }
  async getExistingTestPlans() {
    try {
      const testPlanJsonPath = path9.join(
        this.cacheFrameworkDir,
        _TestPlanner.TEST_PLAN_FILE_NAME
      );
      try {
        await fs10.access(testPlanJsonPath);
      } catch {
        return null;
      }
      const testPlanJson = await fs10.readFile(testPlanJsonPath, "utf-8");
      return JSON.parse(testPlanJson);
    } catch (error) {
      this.log.trace(
        "Failed to read existing analysis",
        getErrorDetails(error)
      );
      return null;
    }
  }
  async createTestPlans() {
    await initializeConfig({});
    const analysis = await getExistingAnalysis(this.frameworkInfo.id);
    const model = createProvider(getConfig().ai);
    this.log.trace("Making AI request to generate test plans");
    const resp = await generateText2({
      system: SYSTEM_PROMPT2,
      model,
      prompt: `Generate a test plan for the attached analysis: ${JSON.stringify(
        analysis
      )}`
    });
    const rawTestPlans = JSON.parse(resp.text);
    const testPlans = TestPlanSchema.parse(rawTestPlans).testPlans;
    return testPlans;
  }
  async saveTestPlansToFile(testPlans) {
    try {
      await fs10.mkdir(this.cacheFrameworkDir, { recursive: true });
      const testPlanJsonPath = path9.join(
        this.cacheFrameworkDir,
        _TestPlanner.TEST_PLAN_FILE_NAME
      );
      const output = {
        metadata: {
          timestamp: Date.now(),
          version: this.TEST_PLAN_VERSION,
          git: await getGitInfo()
        },
        data: {
          testPlans
        }
      };
      await fs10.writeFile(testPlanJsonPath, JSON.stringify(output, null, 2));
      this.log.trace(`Test plan saved to ${testPlanJsonPath}`);
    } catch (error) {
      this.log.error(
        "Failed to save test plans to file",
        getErrorDetails(error)
      );
      throw error;
    }
  }
};

// src/core/test-generator/index.ts
var SHORTEST_DIR_NAME = "shortest";
var SHORTEST_DIR_PATH = path10.join(process.cwd(), SHORTEST_DIR_NAME);
var SHORTEST_EXPECT_NAME = "expect";
var require6 = createRequire5(import.meta.url);
var generate = require6("@babel/generator").default;
var TestGenerator = class {
  rootDir;
  frameworkInfo;
  log = getLogger();
  outputPath;
  TEST_FILE_NAME = "functional.test.ts";
  cacheFrameworkDir;
  constructor(rootDir, frameworkInfo) {
    this.rootDir = rootDir;
    this.frameworkInfo = frameworkInfo;
    this.cacheFrameworkDir = path10.join(
      DOT_SHORTEST_DIR_PATH,
      this.frameworkInfo.id
    );
    this.outputPath = path10.join(SHORTEST_DIR_PATH, this.TEST_FILE_NAME);
  }
  async execute(options = {}) {
    this.log.trace("Generating tests...", { framework: this.frameworkInfo });
    if (!options.force) {
      if (await this.testFileExists()) {
        this.log.trace("Test file already exists, skipping generation", {
          path: this.outputPath
        });
        return;
      }
    }
    await this.generateTestFile();
  }
  async testFileExists() {
    try {
      await fs11.access(this.outputPath);
      return true;
    } catch {
      return false;
    }
  }
  async generateTestFile() {
    const rawFileContent = await this.generateRawFileOutput();
    const formattedCode = await formatCode(
      rawFileContent,
      this.frameworkInfo.dirPath
    );
    const lintedCode = await lintCode(
      formattedCode,
      this.frameworkInfo.dirPath
    );
    try {
      await fs11.mkdir(SHORTEST_DIR_PATH, { recursive: true });
      await fs11.writeFile(this.outputPath, lintedCode);
      this.log.info("Test file generated successfully", {
        path: this.outputPath
      });
    } catch (error) {
      this.log.error("Failed to write tests to file", getErrorDetails(error));
      throw error;
    }
  }
  async generateRawFileOutput() {
    const testPlans = await this.getTestPlans();
    const importStatement = t2.importDeclaration(
      [
        t2.importSpecifier(
          t2.identifier(SHORTEST_NAME),
          t2.identifier(SHORTEST_NAME)
        )
      ],
      t2.stringLiteral("@antiwork/shortest")
    );
    const testStatements = testPlans.map((plan) => {
      const statements = [];
      const statementArgs = [t2.stringLiteral(plan.steps[0])];
      if (plan.options?.requiresAuth) {
        statementArgs.push(
          t2.objectExpression([
            t2.objectProperty(
              t2.identifier("email"),
              t2.memberExpression(
                t2.memberExpression(
                  t2.identifier("process"),
                  t2.identifier("env")
                ),
                t2.identifier("SHORTEST_LOGIN_EMAIL")
              )
            ),
            t2.objectProperty(
              t2.identifier("password"),
              t2.memberExpression(
                t2.memberExpression(
                  t2.identifier("process"),
                  t2.identifier("env")
                ),
                t2.identifier("SHORTEST_LOGIN_PASSWORD")
              )
            )
          ])
        );
      }
      const shortestCall = t2.callExpression(
        t2.identifier(SHORTEST_NAME),
        statementArgs
      );
      const expectChain = plan.steps.slice(1).reduce((acc, step) => {
        const expectCall = t2.callExpression(
          t2.memberExpression(acc, t2.identifier(SHORTEST_EXPECT_NAME)),
          [t2.stringLiteral(step)]
        );
        return expectCall;
      }, shortestCall);
      statements.push(t2.expressionStatement(expectChain));
      return statements;
    }).flat();
    const program2 = t2.program([importStatement, ...testStatements]);
    return generate(program2, {
      retainLines: true,
      compact: false
    }).code;
  }
  async getTestPlans() {
    const testPlanJsonPath = path10.join(
      this.cacheFrameworkDir,
      TestPlanner.TEST_PLAN_FILE_NAME
    );
    const testPlanJson = await fs11.readFile(testPlanJsonPath, "utf-8");
    return JSON.parse(testPlanJson).data.testPlans;
  }
};

// src/cli/commands/generate.ts
var generateCommand = new Command5("generate").description(
  "Generate tests from test plans"
);
generateCommand.addOption(
  new Option5("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).addOption(
  new Option5(
    "--force",
    "Force test generation even if cached data exists"
  ).default(false)
).action(async function() {
  await executeCommand(
    this.name(),
    this.optsWithGlobals(),
    async () => executeGenerateCommand(this.opts())
  );
}).showHelpAfterError("(add --help for additional information)");
var executeGenerateCommand = async (options = {}) => {
  const log = getLogger();
  const cwd = process.cwd();
  const supportedFrameworkInfo = await detectSupportedFramework();
  log.info(`Generating tests...`);
  const generator = new TestGenerator(cwd, supportedFrameworkInfo);
  await generator.execute(options);
  log.info(`Test generation complete.`);
};

// src/cli/commands/github-code.ts
import { Command as Command6, Option as Option6 } from "commander";
import pc7 from "picocolors";
var githubCodeCommand = new Command6("github-code").description("Generate GitHub 2FA code for authentication").addHelpText(
  "after",
  `
${pc7.bold("Environment setup:")}
  Required in ${ENV_LOCAL_FILENAME}:
      GITHUB_TOTP_SECRET                          GitHub 2FA secret
      GITHUB_USERNAME                             GitHub username
      GITHUB_PASSWORD                             GitHub password
`
);
githubCodeCommand.option(
  "--secret <key>",
  `GitHub OTP secret key (can also be set in ${ENV_LOCAL_FILENAME})`
).addOption(
  new Option6("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).action(async function() {
  await executeCommand(
    this.name(),
    this.optsWithGlobals(),
    async () => executeGithubCodeCommand(this.opts().secret)
  );
}).showHelpAfterError("(add --help for additional information)");
var executeGithubCodeCommand = async (secret) => {
  const github = new GitHubTool(secret);
  const { code, timeRemaining } = github.generateTOTPCode();
  console.log("\n" + pc7.bgCyan(pc7.black(" GitHub 2FA Code ")));
  console.log(pc7.cyan("Code: ") + pc7.bold(code));
  console.log(pc7.cyan("Expires in: ") + pc7.bold(`${timeRemaining}s`));
};

// src/cli/commands/init.ts
import { spawn as spawn2 } from "node:child_process";
import { readFile as readFile6 } from "node:fs/promises";
import { Writable } from "node:stream";
import { join as join7 } from "path";
import { select, input, confirm, password } from "@inquirer/prompts";
import { ListrInquirerPromptAdapter } from "@listr2/prompt-adapter-inquirer";
import { Command as Command7, Option as Option7 } from "commander";
import {
  Listr
} from "listr2";
import pc8 from "picocolors";

// src/cli/commands/init/generate-config-file.ts
import { createRequire as createRequire6 } from "module";
import { readFile as readFile3, writeFile as writeFile3 } from "node:fs/promises";
import { join as join4 } from "path";
import { fileURLToPath } from "url";
import * as t3 from "@babel/types";
var require7 = createRequire6(import.meta.url);
var generate2 = require7("@babel/generator").default;
var parser3 = require7("@babel/parser");
var traverse3 = require7("@babel/traverse").default;
var generateConfigFile = async (filePath, configOptions) => {
  const exampleFileDir = fileURLToPath(new URL("../../src", import.meta.url));
  const exampleConfigPath = join4(exampleFileDir, `${CONFIG_FILENAME}.example`);
  const exampleConfigContent = await readFile3(exampleConfigPath, "utf8");
  const ast = parser3.parse(exampleConfigContent, {
    sourceType: "module",
    plugins: ["typescript"]
  });
  if (configOptions.testPattern) {
    const testPattern = configOptions.testPattern;
    traverse3(ast, {
      ObjectProperty(path11) {
        if (t3.isIdentifier(path11.node.key) && path11.node.key.name === "testPattern") {
          path11.node.value = t3.stringLiteral(testPattern);
        }
      }
    });
  }
  const modifiedContent = generate2(ast, {
    retainLines: true,
    compact: false
  }).code;
  const formattedCode = await formatCode(modifiedContent, process.cwd());
  const lintedCode = await lintCode(formattedCode, process.cwd());
  await writeFile3(filePath, lintedCode, "utf8");
};

// src/utils/add-to-gitignore.ts
import { readFile as readFile4, writeFile as writeFile4 } from "node:fs/promises";
import os2 from "os";
import { join as join5 } from "path";
var addToGitignore = async (path11, values) => {
  const result = {
    wasCreated: false,
    wasUpdated: false
  };
  try {
    const gitignorePath = join5(path11, ".gitignore");
    let gitignore = await readFile4(gitignorePath, "utf8").catch(() => null);
    const isNewFile = gitignore === null;
    gitignore ??= "";
    const EOL = gitignore.includes("\r\n") ? "\r\n" : os2.EOL;
    const addValue = (content2, value) => {
      if (!content2.split(EOL).includes(value)) {
        return `${content2}${content2.endsWith(EOL) || content2.length === 0 ? "" : EOL}${value}${EOL}`;
      }
      return content2;
    };
    let modified = false;
    let content = gitignore;
    for (const value of values) {
      const newContent = addValue(content, value);
      if (newContent !== content) {
        modified = true;
        content = newContent;
      }
    }
    if (modified) {
      await writeFile4(gitignorePath, content);
      result.wasCreated = isNewFile;
      result.wasUpdated = !isNewFile;
    }
  } catch (error) {
    result.error = error;
  }
  return result;
};

// src/utils/env-file.ts
import { existsSync as existsSync4 } from "fs";
import { readFile as readFile5, writeFile as writeFile5 } from "node:fs/promises";
import os3 from "os";
import { join as join6 } from "path";
var EnvFile = class {
  path;
  fileName;
  filePath;
  _isNewFile = false;
  _keysAdded = [];
  _keysSkipped = [];
  _content = "";
  _existingEntries = /* @__PURE__ */ new Map();
  _eol = os3.EOL;
  _initialized = false;
  constructor(path11, fileName) {
    this.path = path11;
    this.fileName = fileName;
    this.filePath = join6(path11, fileName);
    this._isNewFile = !existsSync4(this.filePath);
  }
  async initialize() {
    if (this._initialized)
      return;
    try {
      this._content = await readFile5(this.filePath, "utf8").catch(() => "");
      this._eol = this._content.includes("\r\n") ? "\r\n" : os3.EOL;
      this._existingEntries = new Map(
        this._content.split(this._eol).filter((line) => line.trim() && !line.startsWith("#")).map((line) => {
          const [key] = line.split("=");
          return [key.trim(), true];
        })
      );
      this._initialized = true;
    } catch (error) {
      throw error;
    }
  }
  exists() {
    return existsSync4(this.filePath);
  }
  keyExists(key) {
    return this._existingEntries.has(key);
  }
  async add(entry) {
    if (!this._initialized) {
      await this.initialize();
    }
    const { key, value, comment } = entry;
    if (this.keyExists(key)) {
      this._keysSkipped.push(key);
      return false;
    }
    const needsEol = this._content.length > 0 && !this._content.endsWith(this._eol);
    if (comment) {
      this._content += `${needsEol ? this._eol : ""}# ${comment}${this._eol}`;
    }
    this._content += `${needsEol && !comment ? this._eol : ""}${key}=${value}${this._eol}`;
    this._keysAdded.push(key);
    this._existingEntries.set(key, true);
    await writeFile5(this.filePath, this._content);
    return true;
  }
  keysAdded() {
    return [...this._keysAdded];
  }
  keysSkipped() {
    return [...this._keysSkipped];
  }
  isNewFile() {
    return this._isNewFile;
  }
};

// src/cli/commands/init.ts
var initCommand = new Command7("init").description("Initialize Shortest in current directory").addHelpText(
  "after",
  `
${pc8.bold("The command will:")}
- Automatically install the @antiwork/shortest package as a dev dependency if it is not already installed
- Create a default shortest.config.ts file with boilerplate configuration
- Generate a ${ENV_LOCAL_FILENAME} file (unless present) with placeholders for required environment variables, such as ANTHROPIC_API_KEY
- Add ${ENV_LOCAL_FILENAME} and ${DOT_SHORTEST_DIR_NAME} to .gitignore

${pc8.bold("Documentation:")}
  ${pc8.cyan("https://github.com/antiwork/shortest")}
`
);
initCommand.addOption(
  new Option7("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).action(async function() {
  await executeCommand(this.name(), this.optsWithGlobals(), async () => {
    await executeInitCommand();
  });
});
var executeInitCommand = async () => {
  const tasks = new Listr(
    [
      {
        title: "[\u{1F9EA} Experimental Next.js] Confirm sample test file generation",
        task: async (ctx, task) => ctx.generateSampleTestFile = await task.prompt(ListrInquirerPromptAdapter).run(confirm, {
          message: "Do you want to generate a sample test file after installation? This is an experimental feature for Next.js projects.",
          default: true
        })
      },
      {
        title: "Install Shortest",
        task: (_, task) => task.newListr(
          [
            {
              title: "Checking for existing installation",
              task: async (ctx, task2) => {
                const packageJson = await getPackageJson();
                ctx.alreadyInstalled = !!(packageJson?.dependencies?.["@antiwork/shortest"] || packageJson?.devDependencies?.["@antiwork/shortest"]);
                if (ctx.alreadyInstalled) {
                  task2.title = `Shortest is already installed`;
                } else {
                  task2.title = "Shortest is not installed, starting installation.";
                }
              }
            },
            {
              title: "Installing dependencies",
              enabled: (ctx) => !ctx.alreadyInstalled,
              task: async (_2, task2) => {
                const installCmd = await getInstallCmd();
                task2.title = `Executing ${installCmd.toString()}`;
                return spawn2(installCmd.cmd, installCmd.args).stdout;
              },
              rendererOptions: {
                bottomBar: 5
              }
            },
            {
              title: `Setting up environment variables`,
              enabled: (ctx) => !ctx.alreadyInstalled,
              task: (_2, task2) => task2.newListr(
                [
                  {
                    title: `Checking for ${ENV_LOCAL_FILENAME}`,
                    task: async (ctx, task3) => {
                      ctx.envFile = new EnvFile(
                        process.cwd(),
                        ENV_LOCAL_FILENAME
                      );
                      if (ctx.envFile.isNewFile()) {
                        task3.title = `Creating ${ENV_LOCAL_FILENAME}`;
                      } else {
                        task3.title = `Found ${ENV_LOCAL_FILENAME}`;
                      }
                    }
                  },
                  {
                    title: `Adding Anthropic API key`,
                    task: async (_3, task3) => task3.newListr(
                      (parent) => [
                        {
                          title: "Checking for Anthropic API key",
                          task: async (ctx, _4) => {
                            ctx.anthropicApiKeyExists = ctx.envFile.keyExists("ANTHROPIC_API_KEY");
                          }
                        },
                        {
                          title: "Select Anthropic API key name",
                          task: async (ctx, task4) => ctx.anthropicApiKeyName = await task4.prompt(ListrInquirerPromptAdapter).run(select, {
                            message: ctx.anthropicApiKeyExists ? "Anthropic API key already exists. Select the name of the key you want to use." : "Select the name of the Anthropic API key you want to use.",
                            choices: [
                              {
                                name: "ANTHROPIC_API_KEY",
                                value: "ANTHROPIC_API_KEY",
                                description: ctx.anthropicApiKeyExists ? "Use existing API key" : "Use the default API key name"
                              },
                              {
                                name: "SHORTEST_ANTHROPIC_API_KEY",
                                value: "SHORTEST_ANTHROPIC_API_KEY",
                                description: "Use a dedicated API key for Shortest"
                              }
                            ]
                          })
                        },
                        {
                          title: "Enter API key value",
                          enabled: (ctx) => !ctx.anthropicApiKeyExists,
                          task: async (ctx, task4) => ctx.anthropicApiKeyValue = await task4.prompt(ListrInquirerPromptAdapter).run(password, {
                            message: `Enter value for ${ctx.anthropicApiKeyName}`,
                            mask: true
                          })
                        },
                        {
                          title: "Saving API key",
                          enabled: (ctx) => !!ctx.anthropicApiKeyValue,
                          task: async (ctx, _4) => {
                            const keyAdded = await ctx.envFile.add({
                              key: ctx.anthropicApiKeyName,
                              value: ctx.anthropicApiKeyValue
                            });
                            if (keyAdded) {
                              parent.title = `${ctx.anthropicApiKeyName} added`;
                            } else {
                              parent.title = `${ctx.anthropicApiKeyName} already exists, skipped`;
                            }
                          }
                        }
                      ],
                      {
                        rendererOptions: {
                          collapseSubtasks: true
                        }
                      }
                    )
                  },
                  {
                    title: "Adding Shortest login credentials for testing",
                    task: async (_3, task3) => task3.newListr([
                      {
                        title: "Enter the email for the test account",
                        task: async (ctx, task4) => ctx.shortestLoginEmail = await task4.prompt(ListrInquirerPromptAdapter).run(input, {
                          message: `Enter value for SHORTEST_LOGIN_EMAIL. Skip if the application does not require authentication.`
                        })
                      },
                      {
                        title: "Saving SHORTEST_LOGIN_EMAIL key",
                        skip: (ctx) => !ctx.shortestLoginEmail,
                        task: async (ctx, task4) => {
                          const keyAdded = await ctx.envFile.add({
                            key: "SHORTEST_LOGIN_EMAIL",
                            value: ctx.shortestLoginEmail
                          });
                          if (keyAdded) {
                            task4.title = `SHORTEST_LOGIN_EMAIL added`;
                          } else {
                            task4.title = `SHORTEST_LOGIN_EMAIL already exists, skipped`;
                          }
                        }
                      },
                      {
                        title: "Enter the password for the test account",
                        skip: (ctx) => !ctx.shortestLoginEmail,
                        task: async (ctx, task4) => ctx.shortestLoginPassword = await task4.prompt(ListrInquirerPromptAdapter).run(input, {
                          message: `Enter value for SHORTEST_LOGIN_PASSWORD`
                        })
                      },
                      {
                        title: "Saving SHORTEST_LOGIN_PASSWORD key",
                        skip: (ctx) => !ctx.shortestLoginPassword,
                        task: async (ctx, task4) => {
                          const keyAdded = await ctx.envFile.add({
                            key: "SHORTEST_LOGIN_PASSWORD",
                            value: ctx.shortestLoginPassword
                          });
                          if (keyAdded) {
                            task4.title = `SHORTEST_LOGIN_PASSWORD added`;
                          } else {
                            task4.title = `SHORTEST_LOGIN_PASSWORD already exists, skipped`;
                          }
                        }
                      }
                    ])
                  }
                ],
                {
                  rendererOptions: {
                    collapseSubtasks: false
                  }
                }
              )
            },
            {
              title: `Creating ${CONFIG_FILENAME}`,
              enabled: (ctx) => !ctx.alreadyInstalled,
              task: async (ctx, task2) => {
                const testPattern = ctx.generateSampleTestFile ? "shortest/**/*.test.ts" : testPatternSchema._def.defaultValue();
                await generateConfigFile(
                  join7(process.cwd(), CONFIG_FILENAME),
                  {
                    testPattern
                  }
                );
                task2.title = `${CONFIG_FILENAME} created.`;
              }
            },
            {
              title: "Updating .gitignore",
              enabled: (ctx) => !ctx.alreadyInstalled,
              task: async (_2, task2) => {
                const resultGitignore = await addToGitignore(process.cwd(), [
                  ".env*.local",
                  `${DOT_SHORTEST_DIR_NAME}/`
                ]);
                if (resultGitignore.error) {
                  throw new ShortestError(
                    `Failed to update .gitignore: ${resultGitignore.error}`
                  );
                }
                task2.title = `.gitignore ${resultGitignore.wasCreated ? "created" : "updated"}`;
              }
            }
          ],
          {
            rendererOptions: {
              collapseSubtasks: false
            }
          }
        )
      },
      {
        title: "Generate sample test file",
        skip: (ctx) => !ctx.generateSampleTestFile,
        task: async (_, task) => task.newListr(
          [
            {
              title: "Detecting Next.js framework",
              task: async (ctx, task2) => {
                await taskWithCustomLogOutput(task2, async () => {
                  await detectFramework({ force: true });
                  try {
                    ctx.supportedFrameworkInfo = await detectSupportedFramework();
                    task2.title = `${ctx.supportedFrameworkInfo.name} framework detected`;
                  } catch (error) {
                    if (!(error instanceof ShortestError))
                      throw error;
                    task2.title = `Next.js framework not detected (${error.message})`;
                  }
                });
              },
              rendererOptions: {
                bottomBar: 5
              }
            },
            {
              title: "Analyzing the codebase",
              enabled: (ctx) => !!ctx.supportedFrameworkInfo,
              task: async (ctx, task2) => {
                await taskWithCustomLogOutput(task2, async () => {
                  const supportedFrameworkInfo = assertDefined(
                    ctx.supportedFrameworkInfo
                  );
                  const analyzer = new AppAnalyzer(supportedFrameworkInfo);
                  await analyzer.execute({ force: true });
                });
                task2.title = "Analysis complete";
              },
              rendererOptions: {
                bottomBar: 5
              }
            },
            {
              title: "Creating test plans",
              enabled: (ctx) => !!ctx.supportedFrameworkInfo,
              task: async (ctx, task2) => {
                await taskWithCustomLogOutput(task2, async () => {
                  const supportedFrameworkInfo = assertDefined(
                    ctx.supportedFrameworkInfo
                  );
                  const planner = new TestPlanner(supportedFrameworkInfo);
                  await planner.execute({ force: true });
                  task2.title = `Test planning complete`;
                });
              },
              rendererOptions: {
                bottomBar: 5
              }
            },
            {
              title: "Generating test file",
              enabled: (ctx) => !!ctx.supportedFrameworkInfo,
              task: async (ctx, task2) => {
                await taskWithCustomLogOutput(task2, async () => {
                  const supportedFrameworkInfo = assertDefined(
                    ctx.supportedFrameworkInfo
                  );
                  const generator = new TestGenerator(
                    process.cwd(),
                    supportedFrameworkInfo
                  );
                  await generator.execute({ force: true });
                  task2.title = "Test file generated";
                });
              },
              rendererOptions: {
                bottomBar: 5
              }
            }
          ],
          {
            rendererOptions: {
              collapseSubtasks: false
            }
          }
        )
      }
    ],
    {
      renderer: "default",
      exitOnError: true,
      concurrent: false,
      rendererOptions: {
        collapseErrors: false
      }
    }
  );
  try {
    await tasks.run();
    if (tasks.ctx.generateSampleTestFile) {
      console.log(pc8.green("\nSetup complete!"));
      console.log("Run tests with: npx/pnpm shortest");
    } else {
      console.log(pc8.green("\nInitialization complete! Next steps:"));
      console.log("1. Create your first test file: example.test.ts");
      console.log("2. Run tests with: npx/pnpm shortest example.test.ts");
    }
  } catch (error) {
    console.error(pc8.red("Initialization failed"));
    throw error;
  }
};
var getPackageJson = async () => {
  try {
    return JSON.parse(
      await readFile6(join7(process.cwd(), "package.json"), "utf8")
    );
  } catch {
  }
};
var getInstallCmd = async () => {
  const packageManager = await detect() || { agent: "npm", version: "" };
  const packageJson = await getPackageJson();
  if (packageJson?.packageManager) {
    const [name] = packageJson.packageManager.split("@");
    if (["pnpm", "yarn", "bun"].includes(name)) {
      packageManager.agent = name;
    }
  }
  const command = resolveCommand(
    packageManager.agent,
    packageManager.agent === "yarn" ? "add" : "install",
    ["@antiwork/shortest", "--save-dev"]
  );
  if (!command) {
    throw new ShortestError(
      `Unsupported package manager: ${packageManager.agent}`
    );
  }
  const cmdString = `${command.command} ${command.args.join(" ")}`;
  return {
    cmd: command.command,
    args: command.args,
    toString: () => cmdString
  };
};
var taskWithCustomLogOutput = (task, callback) => {
  const log = getLogger();
  const originalFormat = log.config.format;
  const originalLevel = log.config.level;
  log.config.level = "trace";
  const streamAdapter = new Writable({
    write(chunk, _encoding, callback2) {
      task.stdout().write(chunk.toString());
      callback2();
    }
  });
  log.setOutputStream(streamAdapter);
  try {
    const result = callback();
    return Promise.resolve(result).then((value) => {
      log.resetOutputStream();
      log.config.format = originalFormat;
      log.config.level = originalLevel;
      return value;
    });
  } catch (error) {
    log.resetOutputStream();
    log.config.format = originalFormat;
    log.config.level = originalLevel;
    throw error;
  }
};

// src/cli/commands/plan.ts
import { Command as Command8, Option as Option8 } from "commander";
var planCommand = new Command8("plan").description(
  "Generate test plans from app analysis"
);
planCommand.addOption(
  new Option8("--log-level <level>", "Set logging level").choices(LOG_LEVELS)
).addOption(
  new Option8(
    "--force",
    "Force plan generation even if cached data exists"
  ).default(false)
).action(async function() {
  await executeCommand(
    this.name(),
    this.optsWithGlobals(),
    async () => executePlanCommand(this.opts())
  );
}).showHelpAfterError("(add --help for additional information)");
var executePlanCommand = async (options = {}) => {
  const log = getLogger();
  const supportedFrameworkInfo = await detectSupportedFramework();
  log.info(`Generating test plans...`);
  const planner = new TestPlanner(supportedFrameworkInfo);
  const testPlans = await planner.execute(options);
  log.info(`Test planning complete. Generated ${testPlans.length} test plans.`);
};

// src/cli/bin.ts
process.removeAllListeners("warning");
process.on("warning", (warning) => {
  if (warning.name === "DeprecationWarning" && warning.message.includes("punycode")) {
    return;
  }
  console.warn(warning);
});
shortestCommand.addCommand(initCommand);
initCommand.copyInheritedSettings(shortestCommand);
shortestCommand.addCommand(githubCodeCommand);
githubCodeCommand.copyInheritedSettings(shortestCommand);
shortestCommand.addCommand(cacheCommands);
cacheCommands.copyInheritedSettings(shortestCommand);
clearCommand.copyInheritedSettings(cacheCommands);
shortestCommand.addCommand(detectFrameworkCommand);
detectFrameworkCommand.copyInheritedSettings(shortestCommand);
shortestCommand.addCommand(analyzeCommand);
analyzeCommand.copyInheritedSettings(shortestCommand);
shortestCommand.addCommand(planCommand);
planCommand.copyInheritedSettings(shortestCommand);
shortestCommand.addCommand(generateCommand);
generateCommand.copyInheritedSettings(shortestCommand);
var main = async () => {
  try {
    await shortestCommand.parseAsync();
    process.exit(0);
  } catch (error) {
    const log = getLogger();
    log.trace("Handling error on main()");
    if (!(error instanceof ShortestError))
      throw error;
    console.error(pc9.red(error.name), error.message);
    process.exit(1);
  }
};
main().catch(async (error) => {
  const log = getLogger();
  log.trace("Handling error in main catch block");
  if (!(error instanceof ShortestError))
    throw error;
  console.error(pc9.red(error.name), error.message);
  process.exit(1);
});
