import * as playwright from 'playwright';
import { Page, Browser, APIRequest as APIRequest$2, APIRequestContext, BrowserContextOptions } from 'playwright';
import { z } from 'zod';
import { Writable } from 'node:stream';
import { Expect } from 'expect';

interface APIRequest$1 extends RequestInit {
    /**
     * Target URL for the request
     */
    url?: string;
    /**
     * Query parameters to be sent with the URL
     */
    params?: URLSearchParams | string;
    /**
     * Data to be sent with the request
     */
    data?: string;
}
interface APIRequestConfig {
    baseURL: string;
    /**
     * An object containing additional HTTP headers to be sent with every request
     * @default {}
     */
    extraHTTPHeaders: {
        [key: string]: string;
    };
    /**
     * Maximum time in milliseconds to wait for the response
     */
    timeout: number;
    /**
     * Whether to ignore HTTPS errors when sending network requests
     * @default false
     */
    ignoreHTTPSErrors: boolean;
    /**
     * Set cookies for the request
     */
    storageState: SessionStorageState[];
}
interface SessionStorageState {
    name: string;
    value: string;
    domain: string;
    path: string;
    expires: number;
    httpOnly: boolean;
    secure: boolean;
    sameSite: "Strict" | "Lax" | "None";
}
interface APIFetchConfig {
    /**
     * Maximum number of retries to attempt
     * @default 0
     */
    maxRetries: number;
    /**
     * Whether to ignore HTTPS errors when sending network requests
     * This will override the global setting in the APIRequestConfig
     * @default false
     */
    ignoreHTTPSErrors: boolean;
}

declare class APIRequest {
    private config;
    constructor(config?: Partial<APIRequestConfig>);
    fetch(requestBase: APIRequest$1, config?: Partial<APIFetchConfig>): string;
    private processRequest;
}

/**
 * Schema and type definition for test cases in the testing framework
 *
 * @property {string} name - The name of the test case
 * @property {string} filePath - Path to the file containing this test case
 * @property {any} [payload] - Optional data payload for the test
 * @property {Function} [fn] - Optional main test function
 * @property {Array<Expectation>} [expectations] - Array of validation expectations
 * @property {Function} [beforeFn] - Optional setup function to run before the test
 * @property {Function} [afterFn] - Optional cleanup function to run after the test
 * @property {boolean} [directExecution] - Whether to execute test directly (defaults to false)
 * @property {string} identifier - Unique identifier for the test case (auto-generated)
 *
 */
declare const TestCaseSchema: z.ZodEffects<z.ZodObject<{
    name: z.ZodString;
    filePath: z.ZodString;
    payload: z.ZodOptional<z.ZodAny>;
    fn: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodType<TestContext, z.ZodTypeDef, TestContext>], z.ZodUnknown>, z.ZodPromise<z.ZodVoid>>>;
    expectations: z.ZodDefault<z.ZodArray<z.ZodObject<{
        description: z.ZodOptional<z.ZodString>;
        payload: z.ZodOptional<z.ZodAny>;
        fn: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodType<TestContext, z.ZodTypeDef, TestContext>], z.ZodUnknown>, z.ZodPromise<z.ZodVoid>>>;
        directExecution: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    }, "strip", z.ZodTypeAny, {
        directExecution: boolean;
        payload?: any;
        fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
        description?: string | undefined;
    }, {
        payload?: any;
        fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
        description?: string | undefined;
        directExecution?: boolean | undefined;
    }>, "many">>;
    beforeFn: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodType<TestContext, z.ZodTypeDef, TestContext>], z.ZodUnknown>, z.ZodPromise<z.ZodVoid>>>;
    afterFn: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodType<TestContext, z.ZodTypeDef, TestContext>], z.ZodUnknown>, z.ZodPromise<z.ZodVoid>>>;
    directExecution: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    identifier: z.ZodOptional<z.ZodString>;
}, "strict", z.ZodTypeAny, {
    name: string;
    filePath: string;
    directExecution: boolean;
    expectations: {
        directExecution: boolean;
        payload?: any;
        fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
        description?: string | undefined;
    }[];
    payload?: any;
    fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    beforeFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    afterFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    identifier?: string | undefined;
}, {
    name: string;
    filePath: string;
    payload?: any;
    fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    directExecution?: boolean | undefined;
    expectations?: {
        payload?: any;
        fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
        description?: string | undefined;
        directExecution?: boolean | undefined;
    }[] | undefined;
    beforeFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    afterFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    identifier?: string | undefined;
}>, {
    identifier: string;
    name: string;
    filePath: string;
    directExecution: boolean;
    expectations: {
        directExecution: boolean;
        payload?: any;
        fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
        description?: string | undefined;
    }[];
    payload?: any;
    fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    beforeFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    afterFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
}, {
    name: string;
    filePath: string;
    payload?: any;
    fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    directExecution?: boolean | undefined;
    expectations?: {
        payload?: any;
        fn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
        description?: string | undefined;
        directExecution?: boolean | undefined;
    }[] | undefined;
    beforeFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    afterFn?: ((args_0: TestContext, ...args: unknown[]) => Promise<void>) | undefined;
    identifier?: string | undefined;
}>;
type TestCase = z.infer<typeof TestCaseSchema>;

/**
 * Log configuration types and schema.
 *
 * @example
 * ```typescript
 * const config: LogConfig = {
 *   level: "debug",
 *   format: "terminal"
 * };
 * ```
 *
 * @see {@link Log} for usage
 *
 * @private
 */
declare const LOG_LEVELS: readonly ["trace", "debug", "info", "warn", "error", "silent"];
type LogLevel = (typeof LOG_LEVELS)[number];
declare const LogConfigSchema: z.ZodObject<{
    level: z.ZodDefault<z.ZodEnum<["trace", "debug", "info", "warn", "error", "silent"]>>;
    format: z.ZodDefault<z.ZodEnum<["terminal", "pretty", "reporter"]>>;
}, "strip", z.ZodTypeAny, {
    level: "trace" | "debug" | "info" | "warn" | "error" | "silent";
    format: "terminal" | "pretty" | "reporter";
}, {
    level?: "trace" | "debug" | "info" | "warn" | "error" | "silent" | undefined;
    format?: "terminal" | "pretty" | "reporter" | undefined;
}>;
type LogConfig = z.infer<typeof LogConfigSchema>;

/**
 * Core logging class that handles log filtering, grouping, and output rendering.
 *
 * @class
 * @example
 * ```typescript
 * const log = new Log({ level: "debug", format: "terminal" });
 * log.info("Server started", { port: 3000 });
 *
 * // Group related logs
 * log.setGroup("Database");
 * log.debug("Connecting to database...");
 * log.info("Connected successfully");
 * log.resetGroup();
 * ```
 *
 * @param {Partial<LogConfig>} [config] - Optional logger configuration
 * @see {@link LogConfigSchema} for config validation
 * @see {@link LogOutput} for output formatting
 * @see {@link LogGroup} for log grouping
 * @see {@link LogEvent} for event structure
 *
 * @private
 */
declare class Log {
    readonly config: LogConfig;
    private currentGroup?;
    private outputStream;
    constructor(config?: Partial<LogConfig>);
    /**
     * Core logging method that handles metadata extraction and event creation
     */
    log(level: LogLevel, ...args: any[]): void;
    /**
     * Creates a new log group for organizing related logs
     */
    setGroup(name: string): void;
    /**
     * Resets to parent group or removes grouping if at root
     */
    resetGroup(): void;
    /**
     * Removes all group nesting
     */
    resetAllGroups(): void;
    /**
     * Convenience methods for different log levels
     */
    trace(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    setOutputStream(stream: Writable): this;
    resetOutputStream(): this;
    /**
     * Checks if a log level should be output based on configured minimum level
     */
    private shouldLog;
    /**
     * Processes and outputs a log event if it meets the minimum level requirement
     */
    private outputEvent;
}

declare const TokenUsageSchema: z.ZodObject<{
    completionTokens: z.ZodDefault<z.ZodNumber>;
    promptTokens: z.ZodDefault<z.ZodNumber>;
    totalTokens: z.ZodDefault<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    completionTokens: number;
    promptTokens: number;
    totalTokens: number;
}, {
    completionTokens?: number | undefined;
    promptTokens?: number | undefined;
    totalTokens?: number | undefined;
}>;
type TokenUsage = z.infer<typeof TokenUsageSchema>;

declare const testStatusSchema: z.ZodEnum<["pending", "running", "passed", "failed"]>;
type TestStatus = z.infer<typeof testStatusSchema>;

declare enum InternalActionEnum {
    MOUSE_MOVE = "mouse_move",
    LEFT_CLICK = "left_click",
    LEFT_CLICK_DRAG = "left_click_drag",
    RIGHT_CLICK = "right_click",
    MIDDLE_CLICK = "middle_click",
    DOUBLE_CLICK = "double_click",
    TRIPLE_CLICK = "triple_click",
    SCREENSHOT = "screenshot",
    CURSOR_POSITION = "cursor_position",
    GITHUB_LOGIN = "github_login",
    CLEAR_SESSION = "clear_session",
    TYPE = "type",
    KEY = "key",
    HOLD_KEY = "hold_key",
    RUN_CALLBACK = "run_callback",
    NAVIGATE = "navigate",
    SLEEP = "sleep",
    CHECK_EMAIL = "check_email",
    LEFT_MOUSE_DOWN = "left_mouse_down",
    LEFT_MOUSE_UP = "left_mouse_up",
    WAIT = "wait",
    SCROLL = "scroll"
}
type BrowserAction = `${InternalActionEnum}`;
interface ActionInput {
    action: BrowserAction;
    coordinate?: number[];
    coordinates?: number[];
    text?: string;
    username?: string;
    password?: string;
    url?: string;
    duration?: number;
    email?: string;
    scroll_amount?: number;
    scroll_direction?: string;
}

interface CacheAction {
    type: "tool_use" | "text";
    name: BrowserAction;
    input: ActionInput;
}
interface CacheStep {
    reasoning: string;
    action: CacheAction | null;
    timestamp: number;
    result: string | null;
    extras?: any;
}
interface CacheEntry {
    metadata: {
        timestamp: number;
        version: number;
        status: TestStatus;
        reason: string | undefined;
        tokenUsage: TokenUsage;
        runId: string;
        executedFromCache: boolean;
    };
    test: Pick<TestCase, "name" | "filePath">;
    data: {
        steps?: CacheStep[];
    };
}

/**
 * Represents a single test execution with state management and token tracking.
 *
 * @class
 * @example
 * ```typescript
 * const testRun = TestRun.create(testCase);
 * testRun.markRunning();
 * testRun.markPassed({ reason: "Test passed" });
 * ```
 *
 * @see {@link TestCase} for test case structure
 * @see {@link TokenUsage} for token tracking
 */
declare class TestRun {
    /**
     * Creates a new TestRun instance from a test case
     * @param {TestCase} testCase - The test case to be executed
     * @returns {TestRun} A new TestRun instance with pending status
     */
    static create(testCase: TestCase): TestRun;
    /**
     * Creates a TestRun instance from a cache entry
     * @param {TestCase} testCase - The test case associated with this run
     * @param {CacheEntry} cacheEntry - The cache entry data
     * @returns {TestRun} A new TestRun instance
     *
     * @private
     */
    static fromCache(testCase: TestCase, cacheEntry: CacheEntry): TestRun;
    readonly testCase: TestCase;
    readonly log: Log;
    readonly runId: string;
    readonly timestamp: number;
    steps: CacheStep[];
    tokenUsage: TokenUsage;
    version: number;
    private _executedFromCache;
    private state;
    private constructor();
    /**
     * Gets whether this test run was executed from cache
     * @returns {boolean} True if executed from cache, false otherwise
     */
    get executedFromCache(): boolean;
    /**
     * Gets the reason for the current test status
     * @returns {string|undefined} The reason string or undefined if not set
     */
    get reason(): string | undefined;
    /**
     * Gets the current test status
     * @returns {TestStatus} The current status of the test
     */
    get status(): "passed" | "failed" | "pending" | "running";
    /**
     * Marks the test as running
     * @throws {ShortestError} If test is not in pending state
     */
    markRunning(): void;
    /**
     * Marks the test as passed
     * @param {Object} options - Pass options
     * @param {string} options.reason - Reason for passing
     * @param {TokenUsage} [options.tokenUsage] - Optional token usage stats
     * @throws {ShortestError} If test is not in running state
     *
     * @private
     */
    markPassed({ reason, tokenUsage, }: {
        reason: string;
        tokenUsage?: TokenUsage;
    }): void;
    /**
     * Marks the test run as passed when it used a cached test run to be executed
     * @param {Object} options - Options
     * @param {string} options.reason - Reason for passing
     */
    markPassedFromCache({ reason }: {
        reason: string;
    }): void;
    /**
     * Marks the test as failed
     * @param {Object} options - Fail options
     * @param {string} options.reason - Reason for failure
     * @param {TokenUsage} [options.tokenUsage] - Optional token usage stats
     *
     * @private
     */
    markFailed({ reason, tokenUsage, }: {
        reason: string;
        tokenUsage?: TokenUsage;
    }): void;
    /**
     * Adds a step to the test run
     * @param {CacheStep} step - The step to add to the test run
     */
    addStep(step: CacheStep): void;
    /**
     * Gets all steps in this test run
     * @returns {CacheStep[]} A copy of the steps array
     */
    getSteps(): CacheStep[];
}

type TestFileContext = {
    page: Page;
    browser: Browser;
    playwright: typeof playwright & {
        request: APIRequest$2 & {
            newContext: (options?: {
                extraHTTPHeaders?: Record<string, string>;
            }) => Promise<APIRequestContext>;
        };
    };
};
type TestContext = TestFileContext & {
    testRun: TestRun;
    currentStepIndex?: number;
};
type TestChain = {
    expect(fn: (context: TestContext) => Promise<void>): TestChain;
    expect(description: string): TestChain;
    expect(description: string, fn?: (context: TestContext) => Promise<void>): TestChain;
    expect(description: string, payload?: any, fn?: (context: TestContext) => Promise<void>): TestChain;
    before(fn: (context: TestContext) => void | Promise<void>): TestChain;
    after(fn: (context: TestContext) => void | Promise<void>): TestChain;
};
type TestAPI = {
    (fn: (context: TestContext) => Promise<void>): TestChain;
    (name: string): TestChain;
    (names: string[]): TestChain;
    (name: string, fn?: (context: TestContext) => Promise<void>): TestChain;
    (name: string, payload?: any, fn?: (context: TestContext) => Promise<void>): TestChain;
    beforeAll(fn: (context: TestContext) => Promise<void>): void;
    beforeAll(name: string, fn: (context: TestContext) => Promise<void>): void;
    afterAll(fn: (context: TestContext) => Promise<void>): void;
    afterAll(name: string, fn: (context: TestContext) => Promise<void>): void;
    beforeEach(fn: (context: TestContext) => Promise<void>): void;
    beforeEach(name: string, fn: (context: TestContext) => Promise<void>): void;
    afterEach(fn: (context: TestContext) => Promise<void>): void;
    afterEach(name: string, fn: (context: TestContext) => Promise<void>): void;
};

declare const cliOptionsSchema: z.ZodObject<{
    headless: z.ZodOptional<z.ZodBoolean>;
    baseUrl: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    testPattern: z.ZodDefault<z.ZodOptional<z.ZodString>>;
    noCache: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    baseUrl: string;
    testPattern: string;
    headless?: boolean | undefined;
    noCache?: boolean | undefined;
}, {
    headless?: boolean | undefined;
    baseUrl?: string | undefined;
    testPattern?: string | undefined;
    noCache?: boolean | undefined;
}>;
type CLIOptions = z.infer<typeof cliOptionsSchema>;
declare const configSchema: z.ZodObject<{
    headless: z.ZodDefault<z.ZodBoolean>;
    baseUrl: z.ZodString;
    browser: z.ZodDefault<z.ZodObject<{
        contextOptions: z.ZodOptional<z.ZodOptional<z.ZodType<BrowserContextOptions, z.ZodTypeDef, BrowserContextOptions>>>;
    }, "strict", z.ZodTypeAny, {
        contextOptions?: BrowserContextOptions | undefined;
    }, {
        contextOptions?: BrowserContextOptions | undefined;
    }>>;
    testPattern: z.ZodDefault<z.ZodString>;
    anthropicKey: z.ZodOptional<z.ZodString>;
    ai: z.ZodObject<{
        provider: z.ZodLiteral<"anthropic">;
        apiKey: z.ZodDefault<z.ZodString>;
        model: z.ZodDefault<z.ZodEnum<["claude-3-5-sonnet-20241022", "claude-3-5-sonnet-latest", "claude-3-7-sonnet-20250219", "claude-3-7-sonnet-latest"]>>;
    }, "strict", z.ZodTypeAny, {
        provider: "anthropic";
        apiKey: string;
        model: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest";
    }, {
        provider: "anthropic";
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    }>;
    mailosaur: z.ZodOptional<z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        serverId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        apiKey: string;
        serverId: string;
    }, {
        apiKey: string;
        serverId: string;
    }>>>;
    caching: z.ZodDefault<z.ZodOptional<z.ZodObject<{
        enabled: z.ZodDefault<z.ZodBoolean>;
    }, "strict", z.ZodTypeAny, {
        enabled: boolean;
    }, {
        enabled?: boolean | undefined;
    }>>>;
}, "strict", z.ZodTypeAny, {
    headless: boolean;
    baseUrl: string;
    browser: {
        contextOptions?: BrowserContextOptions | undefined;
    };
    testPattern: string;
    ai: {
        provider: "anthropic";
        apiKey: string;
        model: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest";
    };
    caching: {
        enabled: boolean;
    };
    anthropicKey?: string | undefined;
    mailosaur?: {
        apiKey: string;
        serverId: string;
    } | undefined;
}, {
    baseUrl: string;
    ai: {
        provider: "anthropic";
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    };
    headless?: boolean | undefined;
    browser?: {
        contextOptions?: BrowserContextOptions | undefined;
    } | undefined;
    testPattern?: string | undefined;
    anthropicKey?: string | undefined;
    mailosaur?: {
        apiKey: string;
        serverId: string;
    } | undefined;
    caching?: {
        enabled?: boolean | undefined;
    } | undefined;
}>;
declare const userConfigSchema: z.ZodObject<z.objectUtil.extendShape<{
    headless: z.ZodDefault<z.ZodBoolean>;
    baseUrl: z.ZodString;
    browser: z.ZodDefault<z.ZodObject<{
        contextOptions: z.ZodOptional<z.ZodOptional<z.ZodType<BrowserContextOptions, z.ZodTypeDef, BrowserContextOptions>>>;
    }, "strict", z.ZodTypeAny, {
        contextOptions?: BrowserContextOptions | undefined;
    }, {
        contextOptions?: BrowserContextOptions | undefined;
    }>>;
    testPattern: z.ZodDefault<z.ZodString>;
    anthropicKey: z.ZodOptional<z.ZodString>;
    ai: z.ZodObject<{
        provider: z.ZodLiteral<"anthropic">;
        apiKey: z.ZodDefault<z.ZodString>;
        model: z.ZodDefault<z.ZodEnum<["claude-3-5-sonnet-20241022", "claude-3-5-sonnet-latest", "claude-3-7-sonnet-20250219", "claude-3-7-sonnet-latest"]>>;
    }, "strict", z.ZodTypeAny, {
        provider: "anthropic";
        apiKey: string;
        model: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest";
    }, {
        provider: "anthropic";
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    }>;
    mailosaur: z.ZodOptional<z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        serverId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        apiKey: string;
        serverId: string;
    }, {
        apiKey: string;
        serverId: string;
    }>>>;
    caching: z.ZodDefault<z.ZodOptional<z.ZodObject<{
        enabled: z.ZodDefault<z.ZodBoolean>;
    }, "strict", z.ZodTypeAny, {
        enabled: boolean;
    }, {
        enabled?: boolean | undefined;
    }>>>;
}, {
    browser: z.ZodOptional<z.ZodObject<{
        /**
         * @see https://playwright.dev/docs/api/class-browser#browser-new-context
         */
        contextOptions: z.ZodOptional<z.ZodType<BrowserContextOptions, z.ZodTypeDef, BrowserContextOptions>>;
    }, "strip", z.ZodTypeAny, {
        contextOptions?: BrowserContextOptions | undefined;
    }, {
        contextOptions?: BrowserContextOptions | undefined;
    }>>;
    testPattern: z.ZodOptional<z.ZodDefault<z.ZodString>>;
    ai: z.ZodOptional<z.ZodObject<{
        provider: z.ZodOptional<z.ZodLiteral<"anthropic">>;
        apiKey: z.ZodOptional<z.ZodDefault<z.ZodString>>;
        model: z.ZodOptional<z.ZodDefault<z.ZodEnum<["claude-3-5-sonnet-20241022", "claude-3-5-sonnet-latest", "claude-3-7-sonnet-20250219", "claude-3-7-sonnet-latest"]>>>;
    }, "strict", z.ZodTypeAny, {
        provider?: "anthropic" | undefined;
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    }, {
        provider?: "anthropic" | undefined;
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    }>>;
    caching: z.ZodOptional<z.ZodObject<{
        enabled: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    }, "strict", z.ZodTypeAny, {
        enabled?: boolean | undefined;
    }, {
        enabled?: boolean | undefined;
    }>>;
}>, "strict", z.ZodTypeAny, {
    headless: boolean;
    baseUrl: string;
    browser?: {
        contextOptions?: BrowserContextOptions | undefined;
    } | undefined;
    testPattern?: string | undefined;
    anthropicKey?: string | undefined;
    ai?: {
        provider?: "anthropic" | undefined;
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    } | undefined;
    mailosaur?: {
        apiKey: string;
        serverId: string;
    } | undefined;
    caching?: {
        enabled?: boolean | undefined;
    } | undefined;
}, {
    baseUrl: string;
    headless?: boolean | undefined;
    browser?: {
        contextOptions?: BrowserContextOptions | undefined;
    } | undefined;
    testPattern?: string | undefined;
    anthropicKey?: string | undefined;
    ai?: {
        provider?: "anthropic" | undefined;
        apiKey?: string | undefined;
        model?: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest" | undefined;
    } | undefined;
    mailosaur?: {
        apiKey: string;
        serverId: string;
    } | undefined;
    caching?: {
        enabled?: boolean | undefined;
    } | undefined;
}>;
type ShortestConfig = z.infer<typeof userConfigSchema>;
type ShortestStrictConfig = z.infer<typeof configSchema>;

declare global {
    var expect: Expect;
}

declare const initializeConfig: ({ cliOptions, configDir, }: {
    cliOptions?: CLIOptions;
    configDir?: string;
}) => Promise<{
    headless: boolean;
    baseUrl: string;
    browser: {
        contextOptions?: playwright.BrowserContextOptions | undefined;
    };
    testPattern: string;
    ai: {
        provider: "anthropic";
        apiKey: string;
        model: "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-latest" | "claude-3-7-sonnet-20250219" | "claude-3-7-sonnet-latest";
    };
    caching: {
        enabled: boolean;
    };
    anthropicKey?: string | undefined;
    mailosaur?: {
        apiKey: string;
        serverId: string;
    } | undefined;
}>;
declare const getConfig: () => ShortestStrictConfig;
declare const test: TestAPI;
declare const shortest: TestAPI;

export { APIRequest, type ShortestConfig, getConfig, initializeConfig, shortest, test };
